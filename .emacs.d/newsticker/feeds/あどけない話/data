;; -*- coding: utf-8 -*-
(("あどけない話" "あどけない話" "http://d.hatena.ne.jp/kazu-yamamoto/" (20813 17229 655314 937000) feed 0 nil nil ((title nil "あどけない話") (link nil "http://d.hatena.ne.jp/kazu-yamamoto/") (description nil "あどけない話") (dc:creator nil "kazu-yamamoto") (dc:date nil "2013-03-20T15:02:20+09:00") (items nil (rdf:Seq nil (rdf:li ((rdf:resource . "http://d.hatena.ne.jp/kazu-yamamoto/20130319/1363661572"))) (rdf:li ((rdf:resource . "http://d.hatena.ne.jp/kazu-yamamoto/20130318/1363581164"))) (rdf:li ((rdf:resource . "http://d.hatena.ne.jp/kazu-yamamoto/20130311/1362987380"))) (rdf:li ((rdf:resource . "http://d.hatena.ne.jp/kazu-yamamoto/20130308/1362724125"))) (rdf:li ((rdf:resource . "http://d.hatena.ne.jp/kazu-yamamoto/20130206/1360135507"))))))) ("[Haskell]Lensことはじめ" "見ろ！ Haskell が OO のようだ！ さてさて、ようやく重い腰を上げて、Lens を勉強し始めましたよ。Haksell for allを見て勉強すればいいのかなと思ったんですが、解説しているパッケージが data-lens なので古いですね。 今使うべき名のは、lens というパッケージらしいで" "http://d.hatena.ne.jp/kazu-yamamoto/20130319/1363661572" (20807 54020) new 1 nil nil ((title nil "[Haskell]Lensことはじめ") (link nil "http://d.hatena.ne.jp/kazu-yamamoto/20130319/1363661572") (description nil " 見ろ！ Haskell が OO のようだ！ さてさて、ようやく重い腰を上げて、Lens を勉強し始めましたよ。Haksell for allを見て勉強すればいいのかなと思ったんですが、解説しているパッケージが data-lens なので古いですね。 今使うべき名のは、lens というパッケージらしいで") (content:encoded nil "
<div class=\"section\"><blockquote><p>見ろ！ Haskell が OO のようだ！</p></blockquote><p>さてさて、ようやく重い腰を上げて、Lens を勉強し始めましたよ。<a href=\"http://www.haskellforall.com/2012/01/haskell-for-mainstream-programmers_28.html\" target=\"_blank\">Haksell for all</a>を見て勉強すればいいのかなと思ったんですが、解説しているパッケージが data-lens なので古いですね。</p><p>今使うべき名のは、<a href=\"http://hackage.haskell.org/package/lens\" target=\"_blank\">lens</a> というパッケージらしいです。解説は、この README を読むのが一番だそうです。この README と Haskell for all をにらめっこしながら、Lens の getter と setter の機能を使ってみます。</p><h4>背景</h4><p>Haskell の代数データ型にはフィールドラベルが定義できて、これがいわゆる getter と setter の役割を果たします。Haskell for all から例を引用してみましょう。</p><pre class=\"syntax-highlight\"><span class=\"synType\">data</span> Point <span class=\"synStatement\">=</span> Point {
    x <span class=\"synStatement\">::</span> Double
  , y <span class=\"synStatement\">::</span> Double
  } <span class=\"synType\">deriving</span> Show
</pre><p>この定義を GHCi で読み込んで、適当な値を作って p という名前を与えます。</p><pre>
&#62; let p = Point 3.0 4.0
</pre><p>フィールドラベルは getter 関数として使えます。</p><pre>
&#62; x p
3.0
</pre><p>また、フィールドラベルを使えば、差分を指定することで新しい値を作り出せます。</p><pre>
&#62; p { x = 5.0 }
Point {x = 5.0, y = 4.0}
</pre><p>さて問題は、ここからです。次に Point を格納する Circle を定義してみましょう。</p><pre class=\"syntax-highlight\"><span class=\"synType\">data</span> Circle <span class=\"synStatement\">=</span> Circle {
    center <span class=\"synStatement\">::</span> Point
  , radius <span class=\"synStatement\">::</span> Double
  } <span class=\"synType\">deriving</span> Show
</pre><p>この Circle を右に動かす関数を書くとこうなります。</p><pre class=\"syntax-highlight\">
goRight c d <span class=\"synStatement\">=</span> c { center <span class=\"synStatement\">=</span> (center c) { x <span class=\"synStatement\">=</span> x (center c) <span class=\"synStatement\">+</span> d } }
</pre><p>きゃー。醜いですね。せっかくなので使ってみましょう。</p><pre>
&#62; let c = Circle p 5.0
&#62; c
Circle {center = Point {x = 3.0, y = 4.0}, radius = 5.0}
&#62; goRight c 6.0
Circle {center = Point {x = 9.0, y = 4.0}, radius = 5.0}
</pre><h4>Lensを使う</h4><p>Lens を使う場合、フィールドラベルを \"_\" ではじめて makeLenses という呪文を唱えればいいようです。</p><pre class=\"syntax-highlight\"><span class=\"synType\">data</span> Point <span class=\"synStatement\">=</span> Point { 
    _x <span class=\"synStatement\">::</span> Double
  , _y <span class=\"synStatement\">::</span> Double
  } <span class=\"synType\">deriving</span> Show

<span class=\"synType\">data</span> Circle <span class=\"synStatement\">=</span> Circle { 
    _center <span class=\"synStatement\">::</span> Point
  , _radius <span class=\"synStatement\">::</span> Double 
  } <span class=\"synType\">deriving</span> Show

makeLenses ''Point
makeLenses ''Circle
</pre><p>Getter は \"^.\" で利用できます。</p><pre>
&#62; let p = Point 3.0 4.0
&#62; p^.x
3.0
</pre><p>Getter のチェーンも使えます。</p><pre>
&#62; let c = Circle p 5.0
&#62; c^.center^.x
3.0
</pre><p>Setter は \".~\" です。\"&\" と一緒に使います。</p><pre>
&#62;  p&x.~5.0
Point {_x = 5.0, _y = 4.0}
</pre><p>数値であれば、\"+~\"、\"-~\"、および \"*~\" が使えます。</p><pre>
&#62; p&x+~6.0
Point {_x = 9.0, _y = 4.0}
</pre><p>Setter のチェーンを実現するには丸括弧が必要なようです。</p><pre>
&#62; c&(center.x).~7.0
c&(center.x).~7.0
Circle {_center = Point {_x = 7.0, _y = 4.0}, _radius = 5.0}
&#62;c&#38;center&x.~7.0
これはエラー
</pre><p>という訳で、goRight は以下のように実装できます。</p><pre class=\"syntax-highlight\">
goRight c v = c&#38;(center.x)+~v
</pre><p>使ってみましょう。</p><pre>
&#62; goRight c 6.0
Circle {_center = Point {_x = 9.0, _y = 4.0}, _radius = 5.0}
</pre><p>めでたし。めでたし。</p><blockquote><p>どんなに恐ろしい構文を持っても</p><p>たくさんのかわいそうなボイラープレートを操っても</p><p>λから離れては生きられないのよ</p></blockquote></div>
") (dc:creator nil "kazu-yamamoto") (dc:date nil "2013-03-19T11:52:52+09:00") (dc:subject nil "Haskell"))) ("[OCaml]書評「プログラミングの基礎」" "僕はよく「関数プログラミングの入門書には何がいいか」という質問を受ける。そのときは必ずこの本(と他のいくつか)を答えるようにしている。書評を書いたつもりになっていが、検索してみると書いてないようなので、反省して良書を紹介してみようと思う。 プログラミングの" "http://d.hatena.ne.jp/kazu-yamamoto/20130318/1363581164" (20806 39148) new 2 nil nil ((title nil " [OCaml]書評「プログラミングの基礎」") (link nil "http://d.hatena.ne.jp/kazu-yamamoto/20130318/1363581164") (description nil " 僕はよく「関数プログラミングの入門書には何がいいか」という質問を受ける。そのときは必ずこの本(と他のいくつか)を答えるようにしている。書評を書いたつもりになっていが、検索してみると書いてないようなので、反省して良書を紹介してみようと思う。 プログラミングの") (content:encoded nil "
<div class=\"section\"><p>僕はよく「関数プログラミングの入門書には何がいいか」という質問を受ける。そのときは必ずこの本(と他のいくつか)を答えるようにしている。書評を書いたつもりになっていが、検索してみると書いてないようなので、反省して良書を紹介してみようと思う。</p><div class=\"hatena-asin-detail\"><a href=\"http://www.amazon.co.jp/exec/obidos/ASIN/4781911609/kazuyamamoto-22/\"><img src=\"http://ecx.images-amazon.com/images/I/51GBOf09hjL._SL160_.jpg\" class=\"hatena-asin-detail-image\" alt=\"プログラミングの基礎 (Computer Science Library)\" title=\"プログラミングの基礎 (Computer Science Library)\"></a><div class=\"hatena-asin-detail-info\"><p class=\"hatena-asin-detail-title\"><a href=\"http://www.amazon.co.jp/exec/obidos/ASIN/4781911609/kazuyamamoto-22/\">プログラミングの基礎 (Computer Science Library)</a></p><ul><li><span class=\"hatena-asin-detail-label\">作者:</span><a href=\"http://d.hatena.ne.jp/keyword/%C0%F5%B0%E6%B7%F2%B0%EC\" class=\"keyword\">浅井健一</a></li><li><span class=\"hatena-asin-detail-label\">出版社/メーカー:</span><a href=\"http://d.hatena.ne.jp/keyword/%A5%B5%A5%A4%A5%A8%A5%F3%A5%B9%BC%D2\" class=\"keyword\">サイエンス社</a></li><li><span class=\"hatena-asin-detail-label\">発売日:</span> 2007/03</li><li><span class=\"hatena-asin-detail-label\">メディア:</span> 単行本</li><li><span class=\"hatena-asin-detail-label\">購入</span>: 17人 <span class=\"hatena-asin-detail-label\">クリック</span>: 409回</li><li><a href=\"http://d.hatena.ne.jp/asin/4781911609/kazuyamamoto-22\" target=\"_blank\">この商品を含むブログ (99件) を見る</a></li></ul></div><div class=\"hatena-asin-detail-foot\"></div></div><p>本書はプログラミングの経験のない人を対象としており、書名通りプログラミングの基礎が説明されている。使用する言語は OCaml である。著者の浅井先生は、お茶の水女子大学でプログラミングを教えている。授業の経験を元にした本にはよくあることだが、内容が実に整然としており、例題がこなれている。</p><p>初心者を対象としているだけに「構文エラーとは何か」といった基礎的な話題から始まる。なんと言っても本書を特徴付けるのはデザインレシピである。プログラミングをしたことない人が何を書いてよいのか迷わないように、構文や考え方ごとにデザインレシピが用意されている。読んでいくと、手取り足取り教えてくれる講習を受けている感じなのだ。</p><p>一冊を通じて実装して行くのは、メトロネットワークの最短経路問題を解くプログラムである。その過程で探索が必要となる。アルゴリズムを教える際の王道ではあるが、最初はリストの線形探索から始まって、二分木の探索、そして平衡二分木(赤黒木)の探索と、順を追って解説されている。命令型言語の入門書では出てこないようなアルゴリズムにまで踏み込めるのは、関数型言語を使った入門書ならではだろう。</p><p>エラー処理に関しても直和型(option)と例外の使い分けが解説されている。僕自身は関数プログラミングを学んだ際に、長い間この辺りが分からなかったので、実によく書けていると感心した。</p><p>本書では、当たり前のように関数プログラミングを教えて行くので、逐次実行や破壊的代入が出て来るのは第21章以降である。つまり純粋な関数だけでも、かなり本格的なプログラムは書けることが自然とわかるような構成になっている。</p><p>僕もこの本でプログラミングを学んでいれば、遠回りにはしなかったのになぁと思う。</p><p>あえて欠点を挙げるとすれば、</p><ul><li> 関数の型注釈をコメントに書くので機械的な検査の対象にならないこと</li><li> 書名にOCamlという文字列が入ってないこと</li></ul><p>ぐらいだろうか。前者は、mli ファイルに型を書けるのだけれど、複数のファイルを使うと初心者が混乱するので避けるという方針らしい。後者は、たとえば「OCamlで学ぶプログラミングの基礎」という書名であったら、関数プログラミングを学びたいと思っている人のアンテナにひっかかったのになぁと残念に思う。</p><p>ひとことでまとめるなら、本書は素晴らしい。どんなプログラマにも、初心者にも、お薦めできる一冊である。</p></div>
") (dc:creator nil "kazu-yamamoto") (dc:date nil "2013-03-18T13:32:44+09:00"))) ("コンパイルは(テストではなく)証明である" "「プログラムのテストはバグの存在を示すことにかけてはとても効率的な方法ですが、バグの不在を示すことにかけては絶望的なほどに不適切です。プログラムの信頼性を顕著に向上させる唯一の方法は、その正当性に対して説得力のある証明を与えることです」 -- Edsger W. Dijk" "http://d.hatena.ne.jp/kazu-yamamoto/20130311/1362987380" (20797 35188) new 3 nil nil ((title nil "コンパイルは(テストではなく)証明である") (link nil "http://d.hatena.ne.jp/kazu-yamamoto/20130311/1362987380") (description nil " 「プログラムのテストはバグの存在を示すことにかけてはとても効率的な方法ですが、バグの不在を示すことにかけては絶望的なほどに不適切です。プログラムの信頼性を顕著に向上させる唯一の方法は、その正当性に対して説得力のある証明を与えることです」 -- Edsger W. Dijk") (content:encoded nil "
<div class=\"section\"><p>「<a href=\"http://www.unixuser.org/~euske/doc/dijkstra-ja/thehumbleprogrammer.html\" target=\"_blank\">プログラムのテストはバグの存在を示すことにかけてはとても効率的な方法ですが、バグの不在を示すことにかけては絶望的なほどに不適切です。プログラムの信頼性を顕著に向上させる唯一の方法は、その正当性に対して説得力のある証明を与えることです</a>」 -- Edsger W. Dijkstra</p><p>静的型付き言語では、コンパイル時に型が検査される。この型検査に関連して型推論という機能を持つ言語がある。型推論は、大きく分けて2つの意味で使われているようだ。</p><ul><li> 命令型言語の多くに見られる型推論：型検査の過程で、省略された型を補うこと</li><li> 関数型言語の多くに見られる型推論：未知の型を変数として方程式を立て、方程式を解いて未知の型を求めること。型推論自体が型検査の役割を果たす</li></ul><p>この記事では、後者の型推論を話題にする。</p><p>静的型付き関数型言語の利点として、よく「コンパイルはテストである」という説明がなされる。プログラムは式で構成されており、あらゆる部分式が検査の対象となる。コーディング → コンパイルの繰り返しは、言わば最も安価なテスト駆動開発だ。</p><p>「コンパイルはテストである」という説明は、実は多くのプログラマに分かるように配慮された控えめな表現である。本当のことをいうと「コンパイルは証明」なのだ。</p><p>型推論を持つ静的型付き関数型でコードをコンパイルし、型推論による型検査をパスしたなら、型に関するバグは存在しないことが保証される。繰り返しになるが、そう、「コンパイルはテストではなく証明」なのだ。</p><p>コンパイルに通れば型に関するバグはないが、値に対するバグは存在しうるので、もちろんテストを疎かにしてはいけない。しかし、型推論による型検査がない言語に比べて、テストしなければならない項目は激減する。</p><p>型推論による型検査は、安価で便利な自動証明の仕組みだ。静的型付き関数型言語を好むプログラマは「こんなよいものを使わない手はない」と考えている。</p><h4>型エラーを引き延ばす</h4><p>しかし、初心者であれば型に関する間違いがあってもプログラムを動かしたいと思うだろう。その気持ちは、よく分かる。僕も昔はそうだったから。</p><p>静的型付き関数型言語の処理系によっては、コンパイル時の型エラーを実行時まで引き延ばす機能を提供する。たとえば、Haskell の処理系である GHC の最新版は、その機能を持つ。</p><p>以下のコードを考える：</p><pre class=\"syntax-highlight\"><span class=\"synType\">module</span> Main <span class=\"synType\">where</span>

main <span class=\"synStatement\">::</span> IO ()
main <span class=\"synStatement\">=</span><span class=\"synStatement\">do</span><span class=\"synComment\">-- putStrLn は文字列を取る</span>
    putStrLn <span class=\"synConstant\">&#34;Hello, world!&#34;</span> 
    putStrLn <span class=\"synConstant\">1</span><span class=\"synComment\">-- 型エラー</span></pre><p>単純にコンパイルしてみる。</p><pre>
% ghc Main.hs
[1 of 1] Compiling Main             ( Main.hs, Main.o )

Main.hs:7:14:
    No instance for (Num String) arising from the literal `1'
    Possible fix: add an instance declaration for (Num String)
    In the first argument of `putStrLn', namely `1'
    In a stmt of a 'do' block: putStrLn 1
    In the expression:
      do { putStrLn \"Hello, world!\";
           putStrLn 1 }
</pre><p>型エラーとなった。次に -fdefer-type-errors というオプションを指定してコンパイルしてみる。</p><pre>
% ghc -fdefer-type-errors Main.hs
[1 of 1] Compiling Main             ( Main.hs, Main.o )

Main.hs:7:14: Warning:
    No instance for (Num String) arising from the literal `1'
    Possible fix: add an instance declaration for (Num String)
    In the first argument of `putStrLn', namely `1'
    In a stmt of a 'do' block: putStrLn 1
    In the expression:
      do { putStrLn \"Hello, world!\";
           putStrLn 1 }
Linking Main ...
</pre><p>リンクまで到達することが分かる。実行してみよう。</p><pre>
~% ./Main
Hello, world!
Main: Main.hs:7:14:
    No instance for (Num String) arising from the literal `1'
    Possible fix: add an instance declaration for (Num String)
    In the first argument of `putStrLn', namely `1'
    In a stmt of a 'do' block: putStrLn 1
    In the expression:
      do { putStrLn \"Hello, world!\";
           putStrLn 1 }
(deferred type error)
</pre><p>\"Hello, world!\" を表示した後に型エラーになった。</p><p>その内「明らかに誤りのあるコードを動かして何が嬉しいのか」という考え方になるかもしれないが、それまでの間、この機能は便利かもしれない。</p><p>(追記) runghc にこのオプションを指定するには \"--\" が必要のようだ。</p><pre>
% runghc -- -fdefer-type-errors Main.hs
</pre></div>
") (dc:creator nil "kazu-yamamoto") (dc:date nil "2013-03-11T16:36:20+09:00"))) ("静的型付き言語プログラマから見た動的型付き言語" "およそ20年前にAlan Kay の講演をきいたことがある。印象に残ったのは、彼が引き合いに出した McLuhan の言葉だ。 I don’t know who discovered water, but it wasn’t a fish. (拙訳)誰が水を発見したかは知らないが、発見者が魚でなかったことは確かだ。 誰しも信念という" "http://d.hatena.ne.jp/kazu-yamamoto/20130308/1362724125" (20793 34077) new 4 nil nil ((title nil "静的型付き言語プログラマから見た動的型付き言語") (link nil "http://d.hatena.ne.jp/kazu-yamamoto/20130308/1362724125") (description nil " およそ20年前にAlan Kay の講演をきいたことがある。印象に残ったのは、彼が引き合いに出した McLuhan の言葉だ。 I don’t know who discovered water, but it wasn’t a fish. (拙訳)誰が水を発見したかは知らないが、発見者が魚でなかったことは確かだ。 誰しも信念という") (content:encoded nil "
<div class=\"section\"><p>およそ20年前に<a href=\"http://www.mew.org/~kazu/doc/smalltalk.html\" target=\"_blank\">Alan Kay の講演</a>をきいたことがある。印象に残ったのは、彼が引き合いに出した McLuhan の言葉だ。</p><pre>
I don't know who discovered water, but it wasn't a fish.
</pre><pre>
(拙訳)誰が水を発見したかは知らないが、発見者が魚でなかったことは確かだ。
</pre><p>誰しも信念という水の中を泳ぐ魚のような存在だ。思い切って飛び跳ね空気に触れてみなれば、自分が信念という水の中にいることに気付かない。</p><p>ある手法の利点を語るには、その手法の欠点や、他の手法の利点や欠点とできるだけ客観的に比較しなければ説得力がない。ただ、これを実践するのは難しい。この記事では、客観的になれているか自問自答しながら、動的型付き言語と静的型付き言語について比較してみようと思う。</p><p>僕は静的な C 言語から、動的な Perl、Lisp、JavaScript を経て、現在では静的な Haskell を主に使っている。だから静的型付き言語から動的型付き言語に移った人の気持ちも分かるつもりだし、その逆も分かるつもりだ。(いや、分からないことも多いんだろうけど。)</p><p>一口に動的型付き言語、静的型付き言語といっても実にさまざまで、本当は十把一絡げに議論することはできない。しかし、細部にこだわると言いたいことが伝わらなくなると思うので、細かい点には目をつぶって頂けると嬉しい。</p><p>以下では僕の立場上、動的型付き言語のプログラマが主張する動的型付き言語の利点や静的型付き言語の欠点が、静的型付き「関数型」言語のプログラマからどういう風に見えるのかという話になる。</p><p>すべての動的型付き言語のプログラマがそういう主張をしているとは思っていないし、静的型付き関数型言語を一括りにするのも乱暴なのは承知している。「なんか違うな」と感じたら、建設的なブログ記事をなどを書いて議論して頂けるとありがたい。</p><h4>スクリプト</h4><p>「動的型付き言語はコンパイルせずにスクリプトとして走らせることができて楽だ」</p><p>静的型付き言語であってもコンパイルして実行するというラッパープログラムを書けば、スクリプトのように実行できる。実際、静的型付き関数型言語では、そいうラッパープログラムを提供しているものが多いし、よく使われている。</p><p>以下は Haskell の例：</p><pre>
% runhaskell HelloWorld.hs
Hello, world!
</pre><h4>記述量</h4><p>「動的型付き言語では型注釈を書かなくてもいいので記述量が減って楽だ」</p><p>うまく設計された静的型付き言語では、型注釈と定義が分離されている。以下は Haskell の例：</p><pre class=\"syntax-highlight\">
repl <span class=\"synStatement\">::</span> Int <span class=\"synStatement\">-&#62;</span> Char <span class=\"synStatement\">-&#62;</span> [Char] <span class=\"synComment\">-- ここが型注釈</span>
repl <span class=\"synConstant\">0</span> _ <span class=\"synStatement\">=</span> []                 <span class=\"synComment\">-- これ以降が関数の定義</span>
repl n c <span class=\"synStatement\">=</span> c <span class=\"synStatement\">:</span> repl (n<span class=\"synStatement\">-</span><span class=\"synConstant\">1</span>) c
</pre><p>だから、型注釈は省略して書ける。</p><pre class=\"syntax-highlight\">
repl <span class=\"synConstant\">0</span> _ <span class=\"synStatement\">=</span> []
repl n c <span class=\"synStatement\">=</span> c <span class=\"synStatement\">:</span> repl (n<span class=\"synStatement\">-</span><span class=\"synConstant\">1</span>) c
</pre><p>静的型付き関数型言語の多くは、型推論という機能を持ち、定義から型を推測する。そこで必要であればコンパイラが推論した型をプログラミング環境が自動的に挿入してくれる。</p><p>逆に、Haskell では型を先に書いて、型レベルで設計することもある(ちょうどオブジェクト指向のプログラマが UML を書くように)。</p><pre class=\"syntax-highlight\">
repl <span class=\"synStatement\">::</span> Int <span class=\"synStatement\">-&#62;</span> Char <span class=\"synStatement\">-&#62;</span> [Char] <span class=\"synComment\">-- ここが型注釈</span>
repl <span class=\"synStatement\">=</span> undefined              <span class=\"synComment\">-- 型検査をごまかす関数定義</span></pre><p>僕の場合は</p><ul><li> 簡単な関数はいちいち型注釈を書きたくないので、定義から書いて型注釈は自動挿入</li><li> 難しい関数は型注釈を書いて型のレベルで設計し、後から定義を書く (この場合、型が実装を導いてくれる)</li></ul><p>のように使い分けている。</p><h4>対話環境</h4><p>「動的型付き言語では対話環境があるので開発効率がよい」</p><p>対話環境があれば開発効率がよいという主張には完全に同意。でも、静的型付き関数型言語の多くにも対話環境がある。個人的な意見では、対話環境がある言語でもリテラルが充実してないのであれば、対話環境の利点が半減していると思う。</p><p>たとえば、Haskell で定義されたデータは、それがそのままリテラルとなり、関数の入力にも使えるし、出力の際もそのままの形で表示される。以下 Haskell で木を定義する例：</p><pre class=\"syntax-highlight\"><span class=\"synType\">data</span> Tree a <span class=\"synStatement\">=</span> Leaf a <span class=\"synStatement\">|</span> Node (Tree a) (Tree a) <span class=\"synType\">deriving</span> (Show,Functor)
</pre><p>以下は、定義した木を対話環境 GHCi で使う例：</p><pre>
% ghci Tree.hs
&#62; fmap (+1) (Node (Leaf 1) (Leaf 2))
Node (Leaf 2) (Leaf 3)
</pre><p>入力も出力も定義がそのままリテラルになっていることが分かるだろう。</p><h4>テスト</h4><p>「動的型付き言語はテストしやすい」</p><p>これは意味が分からなかったのだが、たとえば「呼び出すメソッドを実行時に決定する機能を使ってモックを差し込むことがやりやすい」ことなど言っているのではないかと教えて頂いた。</p><p>たしかに静的型付き言語のオブジェクトをテストするのに比べれば、動的型付き言語のオブジェクトをテストする方がやりやすいだろう。でも、それはオブジェクト指向で考えているからではないか(十把一絡げにしてすいません)？</p><p>関数プログラミングの場合は、差し替えたい部分があるなら、そこは引数にしておく。だから、テストのために「実行時に呼び出すメソッドを変えたい」とは思わない。引数を変えればいいからだ。</p><p>少し話がそれるけれど、関数型言語では副作用のある関数とない関数を分けて書く習慣を身につけているプログラマが多い。副作用のない関数は、引数だけから結果が決まるのでテストしやすい。副作用のある関数でも、上記のように動作を変えたい部分は、引数にしてテストしやすいように工夫する。</p><p>世の中のコードはうまく設計されているものばかりじゃない。うまく設計されてないコードを手渡されたときに、実行時に呼び出すメソッドが変えられるのでテストしやすい。そういう意見には一理あると思うけど、僕だと(変更が許されるなら)リファクタリングしてテストしやすく変更すると思う。その方が保守しやすくなるからね。</p><p>ちなみに、副作用のない関数に関しては、テストケースを自動的に生成するというテスト手法があって、静的型付き関数型言語ではよく使われている。この種のテストでは、関数が持つべき「性質」を記述する。以下、ある方法で符号化して復号化すれば、元に戻るという性質の例：</p><pre class=\"syntax-highlight\">
prop_encodeDecode <span class=\"synStatement\">::</span> String <span class=\"synStatement\">-&#62;</span> Bool
prop_encodeDecode xs <span class=\"synStatement\">=</span> decode (encode xs) <span class=\"synStatement\">==</span> xs
</pre><p>対話的にテストしてみる：</p><pre>
&#62; quickCheck prop_encodeDecode
OK, passed 100 tests.
</pre><p>100個の乱数が生成されて、すべてテストを通過したことが分かる。値の生成方法にも、乱数的に生成する方法の他に、ある大きさを網羅する方法などがある。</p><p>テストの世界は広くて深い。ある局面で「テストしやすい」と言われても「あなたの場合だとそうなんでしょうね」という感想になることが多い。</p><h4>メタプログラミング (追記)</h4><p>「動的型付き言語は、実行時に環境に応じたメタプログラミングができる」</p><p>これは、たとえば実行時に DB のスキーマを取ってきて、必要なメソッドをメタプログラミングで自動生成することなどを言っている。しかし、静的型付き言語でも、コンパイル時に DB のスキーマを取ってきて必要な関数/メソッドを自動生成できる。</p><p>スキーマが変わる度にコンパイルするのは面倒と感じるか、コンパルしてある程度の品質を保証したいと思うかは、プログラマ次第だ。</p><h4>不完全</h4><p>「動的型付き言語は不完全なコードを実行できる」</p><p>おそらく動的型付き言語の利点は、この言葉に集約されると思う。ただ、これはかなり大雑把な表現なので、もう少し厳密に議論したい。</p><p>まず、静的型付き言語でも不完全なコードは実行できる。たとえば、この C 言語のコード；</p><pre class=\"syntax-highlight\"><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&#60;stdio.h&#62;</span><span class=\"synType\">void</span> main () {
}
</pre><p>何も実装してないから(仕様を満たさないという意味で)不完全だけど、コンパイルもできるし、実行もできる。別の例として undefined を使った不完全でも実行できる Haskell コードを最初の方で示した。</p><p>という訳で、言いたいことは分かるんだけれど、もう少し的確な表現を使う方がいいと思う。以下では、このテーマを細分化して議論していく。</p><h4>少ない手間で不完全</h4><p>「動的型付き関数型言語では、少ない手間で不完全なコードを記述できる」</p><p>「少ない手間」とは、ある部分であるメソッドを呼び出しているのに、そのメソッドの定義は一文字も書かれていないなどを言っている。</p><p>ただ、静的型付き言語では、定義されてないメソッドや関数があれば、プログラミング環境が関数定義の雛形を自動挿入できるので、動的型付き言語の利点とは言えないと思う。</p><h4>インターフェイスの柔軟な変更</h4><p>「動的型付き関数型言語では、公開しているインターフェイスの互換性を保ちながら、新しい仕様に変更できる」</p><p>たとえば、第一引数が整数で第二引数が文字列である関数を公開しているとしよう。利用して行く過程で、順番は逆の方がいいと気付いた。</p><p>動的型付き言語であれば、実行時に第一引数の型を検査し、整数なら古い仕様で、文字列なら新しい仕様で動くということが可能だ。もし、自分が提供するライブラリの顧客が、顧客側のコードの変更を認めてくれないのであれば、こういう対策が必要になる。こういった状況では、動的型付き言語の方が有利。</p><p>ただ、静的型付き言語のプログラマは、このような変更がなされたら、速やかに新しいインターフェイスに移行するべきだと考えている。コンパイラは、変更すべき箇所をすべて見つけてくれるので、顧客が変更を認めてくれないという状況でない限り、変更は可能だし、変更の手間もかからない(ただ必要な人への連絡は手間だ)。</p><p>これは一長一短である。</p><p>静的型付き言語のプログラマにとっては、変更すべき箇所を指摘するツールがないのは不安に感じるだろう。(静的解析ツールを提供している動的型付き言語もあるが、言語処理系に組み込まれていないと、言語処理系の変化に取り残されてることがよくある。)</p><p>動的型付き言語のプログラマにとっては、変更に対する柔軟性がないのは不安に感じるだろう。</p><h4>ユーザインターフェイスとしての言語</h4><p>「動的型付き言語は、あるシステムを制御するユーザインターフェイス言語に向いている」</p><p>あるシステムを制御するユーザインターフェイス言語とは、たとえば Emacs を制御する Emacs Lisp やブラウザを制御する JavaScript が挙げられる。これらの言語は、たとえコードが不完全でも動き続けなければいけない。だから、あるシステムを制御するユーザインターフェイス言語の設計者は、自然と動的型付き言語を選択するだろう。</p><p>ただし、動的型付き言語は品質の面に不安があるので、コード生成を利用しているプログラマもいる。最近では、コードを静的型付き言語で記述しておき、コンパイルである程度の品質を保証してから、JavaScript を生成するという方法が一部で流行っている。こういう使い方をするプログラマにとっては、JavaScript とはブラウザを制御するためのアセンブリ言語である。</p><h4>ホットスワップ</h4><p>「動的型付き言語では、コードのホットスワップができる」</p><p>動き続けなければならないサーバのコードの一部をバージョンアップしたい。動的型付き言語の Erlang で書かれたサーバでは、コードのホットスワップが当たり前のように実践されている。</p><p>静的型付き言語でもやってやれないことはないと思うけど、動的型付き言語の方が圧倒的にやりやすいのは間違いない。</p><h4>デバッガでのプログラミング</h4><p>「動的型付き言語では、変わりゆく世界を動的に捕まえてプログラミングできる」</p><p>コードを書いたときには想定してなかったか、気付いてはいたがどう対処すればよいのか分からずにそのままにしていた箇所があるとしよう。優れた動的型付き言語では、そこを踏むとデバッガが起動する。そして、デバッガの中で対処するコードを書いて再実行すれば、あたかも前からコードがあったかのように動いてくれる。</p><p>優れた動的型付き言語の優れたプログラマは、もう再現できないかもしれない千載一遇のチャンスを無駄にしたくない。だから、このようなプログラマにとっては、デバッガなどのプログラミング環境がプログラミング言語だ。</p><p>このようなプログラミングを実践しているプログラマは、本当に尊敬する。残念ながら、静的型付き言語では、このようなプログラミングはできないか、相当無理がある。</p><h4>まとめ</h4><p>僕の考える動的型付き言語の利点をまとめると以下のようになる。</p><ul><li> インターフェイスを変更できない状況で、柔軟に対応できる</li><li> 不完全な場合でも動き続けなければならない状況で動き続けられる</li><li> コードのホットスワップがやりやすい</li><li> 変わりゆく世界を動的に捕まえてプログラミングできる</li></ul><p>欠点は、以下のような点：</p><ul><li> たくさんテストを書かないと品質が保証できない</li><li> 不整合な部分を発見する手段が提供されてないことが多い</li></ul><p>僕の場合は、動的型付き言語の欠点の方が大きいので、静的型付き言語 Haskell を使っている。</p><h4>おまけ</h4><p>動的型付き言語のプログラマが知らないかもしれない世界として、静的型付き関数型言語では「型が実装を導いてくれる」ということが挙げられる。もし知らないのであれば、実際に体験してみると静的型付き言語に対しての印象も変わるかもしれない。</p></div>
") (dc:creator nil "kazu-yamamoto") (dc:date nil "2013-03-08T15:28:45+09:00"))) ("[Haskell]PFAD(1): The smallest free number" "与えられた自然数リストの中に存在しない最小の自然数を求める問題。(ここでの自然数は 0 から始まる。) 素朴には、以下のように実装できる。 minfree :: [Int] -> Int minfree xs = head $ [0..] ￥￥ xs (￥￥) :: Eq a => [a] -> [a] -> [a] us ￥￥ vs = filt" "http://d.hatena.ne.jp/kazu-yamamoto/20130206/1360135507" (20754 1363) new 5 nil nil ((title nil "[Haskell]PFAD(1): The smallest free number") (link nil "http://d.hatena.ne.jp/kazu-yamamoto/20130206/1360135507") (description nil " 与えられた自然数リストの中に存在しない最小の自然数を求める問題。(ここでの自然数は 0 から始まる。) 素朴には、以下のように実装できる。 minfree :: [Int] -> Int minfree xs = head $ [0..] ￥￥ xs (￥￥) :: Eq a => [a] -> [a] -> [a] us ￥￥ vs = filt") (content:encoded nil "
<div class=\"section\"><p>与えられた自然数リストの中に存在しない最小の自然数を求める問題。(ここでの自然数は 0 から始まる。)</p><p>素朴には、以下のように実装できる。</p><pre class=\"syntax-highlight\">
minfree <span class=\"synStatement\">::</span> [Int] <span class=\"synStatement\">-&#62;</span> Int
minfree xs <span class=\"synStatement\">=</span> head <span class=\"synStatement\">$</span> [<span class=\"synConstant\">0</span><span class=\"synStatement\">..</span>] <span class=\"synStatement\">\\\\</span> xs

(<span class=\"synStatement\">\\\\</span>) <span class=\"synStatement\">::</span> Eq a <span class=\"synStatement\">=&#62;</span> [a] <span class=\"synStatement\">-&#62;</span> [a] <span class=\"synStatement\">-&#62;</span> [a]
us <span class=\"synStatement\">\\\\</span> vs <span class=\"synStatement\">=</span> filter (<span class=\"synStatement\">`notElem`</span> vs) us)
</pre><p>us と vs の長さをそれぞれ N と M とすると、(\\\\) の計算量は O(NM) となる。ちなみに Data.List での定義は、もう少し効率がよくなっている。</p><pre class=\"syntax-highlight\">
(<span class=\"synStatement\">\\\\</span>) <span class=\"synStatement\">::</span> (Eq a) <span class=\"synStatement\">=&#62;</span> [a] <span class=\"synStatement\">-&#62;</span> [a] <span class=\"synStatement\">-&#62;</span> [a]
(<span class=\"synStatement\">\\\\</span>) <span class=\"synStatement\">=</span> foldl (flip delete)
</pre><p>とにかく (\\\\) は効率が悪いので、minfree からなくしたい。(++) と head の性質を使って、(\\\\) をなくすのが、本章の本質である。</p><p>as と vs に共通要素がなく、bs と us にも共通要素がなければ、以下の性質が成り立つ。</p><pre>
(as ++ bs) \\\\ (us ++ vs) = as \\\\ us ++ bs \\\\ vs
</pre><p>蛇足：計算量は (\\\\) よりも (++) の方が少ない。よって、これは等式であるにも関わらず、左辺よりも右辺の方が計算量が少ない。この性質を使って計算量を落とす方法をセミリングヒュージョンというが、この章には関係なかった。以下のように head の性質を用いて、右辺の一方の式を削除し、他方のみを計算するという手法を使う。</p><p>minfree に出てきた [0..] \\\\ xs という式は、任意の自然数 b を用いて以下のように変形できる。</p><pre class=\"syntax-highlight\">
[<span class=\"synConstant\">0</span><span class=\"synStatement\">..</span>] <span class=\"synStatement\">\\\\</span> xs <span class=\"synStatement\">=</span> ([<span class=\"synConstant\">0</span><span class=\"synStatement\">..</span>b<span class=\"synStatement\">-</span><span class=\"synConstant\">1</span>] <span class=\"synStatement\">\\\\</span> us) <span class=\"synStatement\">++</span> ([b<span class=\"synStatement\">..</span>] <span class=\"synStatement\">\\\\</span> vs)
  <span class=\"synType\">where</span>
    (us,vs) <span class=\"synStatement\">=</span> partition (<span class=\"synStatement\">&#60;</span> b) xs
</pre><p>なお、Data.List での partition の定義は以下の通りで、計算量は O(N) である。</p><pre class=\"syntax-highlight\">
partition               <span class=\"synStatement\">::</span> (a <span class=\"synStatement\">-&#62;</span> Bool) <span class=\"synStatement\">-&#62;</span> [a] <span class=\"synStatement\">-&#62;</span> ([a],[a])
partition p xs <span class=\"synStatement\">=</span> foldr (select p) ([],[]) xs

select <span class=\"synStatement\">::</span> (a <span class=\"synStatement\">-&#62;</span> Bool) <span class=\"synStatement\">-&#62;</span> a <span class=\"synStatement\">-&#62;</span> ([a], [a]) <span class=\"synStatement\">-&#62;</span> ([a], [a])
select p x <span class=\"synStatement\">~</span>(ts,fs) <span class=\"synStatement\">|</span> p x       <span class=\"synStatement\">=</span> (x<span class=\"synStatement\">:</span>ts,fs)
                    <span class=\"synStatement\">|</span> otherwise <span class=\"synStatement\">=</span> (ts, x<span class=\"synStatement\">:</span>fs)
</pre><p>ちなみに、\"~\" は遅延パターン。</p><p>次に考えたいのは head $ ([0..b-1] \\\\ us) ++ ([b..] \\\\ vs) である。head $ xs ++ ys は、以下のように変形できる。</p><pre class=\"syntax-highlight\">
head <span class=\"synStatement\">$</span> xs <span class=\"synStatement\">++</span> ys <span class=\"synStatement\">=</span><span class=\"synStatement\">if</span> null xs <span class=\"synStatement\">then</span> head ys <span class=\"synStatement\">else</span> head xs
</pre><p>よって、minfree xs は、任意の b があると仮定して、以下のように変形できる。</p><pre class=\"syntax-highlight\"><span class=\"synComment\">-- minfree xs =</span><span class=\"synComment\">--   head $ [0..] \\\\ xs</span><span class=\"synComment\">--     ↓</span><span class=\"synComment\">--   head $ ([0..b-1] \\\\ us) ++ ([b..] \\\\ vs)</span><span class=\"synComment\">--     ↓</span><span class=\"synComment\">--   if null ([0..b-1] \\\\ us) then head ([b..] \\\\ vs) then head ([0..b-1] \\\\ us)</span>
minfree xs
  <span class=\"synStatement\">|</span> null ([<span class=\"synConstant\">0</span><span class=\"synStatement\">..</span>b<span class=\"synStatement\">-</span><span class=\"synConstant\">1</span>] <span class=\"synStatement\">\\\\</span> us) <span class=\"synStatement\">=</span> head <span class=\"synStatement\">$</span> [b<span class=\"synStatement\">..</span>] <span class=\"synStatement\">\\\\</span> vs
  <span class=\"synStatement\">|</span> otherwise             <span class=\"synStatement\">=</span> head <span class=\"synStatement\">$</span> [<span class=\"synConstant\">0</span><span class=\"synStatement\">..</span>] <span class=\"synStatement\">\\\\</span> us
  <span class=\"synType\">where</span>
    (us,vs) <span class=\"synStatement\">=</span> partition (<span class=\"synStatement\">&#60;</span> b) xs
    b <span class=\"synStatement\">=</span> undefined
</pre><p>次は、null の中の (\\\\) をなくす。us は、b より小さい自然数のリストだから、us の長さが b であれば、[0..b-1]と同じリストとなり、(\\\\) を取ると空リストになる。よって、</p><pre class=\"syntax-highlight\">
minfree xs
  <span class=\"synStatement\">|</span> length us <span class=\"synStatement\">==</span> b <span class=\"synStatement\">=</span> head <span class=\"synStatement\">$</span> [b<span class=\"synStatement\">..</span>] <span class=\"synStatement\">\\\\</span> vs
  <span class=\"synStatement\">|</span> otherwise      <span class=\"synStatement\">=</span> head <span class=\"synStatement\">$</span> [<span class=\"synConstant\">0</span><span class=\"synStatement\">..</span>] <span class=\"synStatement\">\\\\</span> us
  <span class=\"synType\">where</span>
    (us,vs) <span class=\"synStatement\">=</span> partition (<span class=\"synStatement\">&#60;</span> b) xs
    b <span class=\"synStatement\">=</span> undefined
</pre><p>最後に、右辺の(\\\\) をなくそう。補助関数 minfrom を以下のように定義する。minfrom は、無限リストの開始の値を引数に取る。</p><pre class=\"syntax-highlight\">
minform a xs <span class=\"synStatement\">=</span> head <span class=\"synStatement\">$</span> [a<span class=\"synStatement\">..</span>] <span class=\"synStatement\">\\\\</span> xs
</pre><p>minfree と同様に、これは以下のように変形できる。</p><pre class=\"syntax-highlight\">
minfrom a xs
  <span class=\"synStatement\">|</span> length us <span class=\"synStatement\">==</span> b <span class=\"synStatement\">-</span> a <span class=\"synStatement\">=</span> head <span class=\"synStatement\">$</span> [b<span class=\"synStatement\">..</span>] <span class=\"synStatement\">\\\\</span> vs
  <span class=\"synStatement\">|</span> otherwise          <span class=\"synStatement\">=</span> head <span class=\"synStatement\">$</span> [a<span class=\"synStatement\">..</span>] <span class=\"synStatement\">\\\\</span> us
  <span class=\"synType\">where</span>
    (us,vs) <span class=\"synStatement\">=</span> partition (<span class=\"synStatement\">&#60;</span> b) xs
    b <span class=\"synStatement\">=</span> undefined
</pre><p>minfrom の定義から、さらに再帰的に変形できる。(再帰を止めることを忘れないこと。)</p><pre class=\"syntax-highlight\">
minfrom <span class=\"synStatement\">::</span> Int <span class=\"synStatement\">-&#62;</span> [Int] <span class=\"synStatement\">-&#62;</span> Int
minfrom a xs
  <span class=\"synStatement\">|</span> null xs            <span class=\"synStatement\">=</span> a
  <span class=\"synStatement\">|</span> length us <span class=\"synStatement\">==</span> b <span class=\"synStatement\">-</span> a <span class=\"synStatement\">=</span> minfrom b vs
  <span class=\"synStatement\">|</span> otherwise          <span class=\"synStatement\">=</span> minfrom a us
  <span class=\"synType\">where</span>
    (us,vs) <span class=\"synStatement\">=</span> partition (<span class=\"synStatement\">&#60;</span> b) xs
    b <span class=\"synStatement\">=</span> undefined
</pre><p></p><p>b を以下のように二分割するような値に取る。</p><pre class=\"syntax-highlight\">
minfrom <span class=\"synStatement\">::</span> Int <span class=\"synStatement\">-&#62;</span> [Int] <span class=\"synStatement\">-&#62;</span> Int
minfrom a xs
  <span class=\"synStatement\">|</span> null xs            <span class=\"synStatement\">=</span> a
  <span class=\"synStatement\">|</span> length us <span class=\"synStatement\">==</span> b <span class=\"synStatement\">-</span> a <span class=\"synStatement\">=</span> minfrom b vs
  <span class=\"synStatement\">|</span> otherwise          <span class=\"synStatement\">=</span> minfrom a us
  <span class=\"synType\">where</span>
    (us,vs) <span class=\"synStatement\">=</span> partition (<span class=\"synStatement\">&#60;</span> b) xs
    b <span class=\"synStatement\">=</span> a <span class=\"synStatement\">+</span><span class=\"synConstant\">1</span><span class=\"synStatement\">+</span> n <span class=\"synStatement\">`div`</span><span class=\"synConstant\">2</span>
    n <span class=\"synStatement\">=</span> length xs
</pre><p>最後に、あるリストに対して length が複数回呼ばれないように、以下のように変形する。</p><pre class=\"syntax-highlight\">
minfrom <span class=\"synStatement\">::</span> Int <span class=\"synStatement\">-&#62;</span> (Int,[Int]) <span class=\"synStatement\">-&#62;</span> Int
minfrom a (n,xs)
  <span class=\"synStatement\">|</span> n <span class=\"synStatement\">==</span><span class=\"synConstant\">0</span><span class=\"synStatement\">=</span> a
  <span class=\"synStatement\">|</span> m <span class=\"synStatement\">==</span> b <span class=\"synStatement\">-</span> a         <span class=\"synStatement\">=</span> minfrom b (n <span class=\"synStatement\">-</span> m, vs)
  <span class=\"synStatement\">|</span> otherwise          <span class=\"synStatement\">=</span> minfrom a (m,     us)
  <span class=\"synType\">where</span>
    (us,vs) <span class=\"synStatement\">=</span> partition (<span class=\"synStatement\">&#60;</span> b) xs
    b <span class=\"synStatement\">=</span> a <span class=\"synStatement\">+</span><span class=\"synConstant\">1</span><span class=\"synStatement\">+</span> n <span class=\"synStatement\">`div`</span><span class=\"synConstant\">2</span>
    m <span class=\"synStatement\">=</span> length us
</pre><p>minfrom を使うと、minfree は最終的に以下のように定義できる。</p><pre class=\"syntax-highlight\">
minfree <span class=\"synStatement\">::</span> [Int] <span class=\"synStatement\">-&#62;</span> Int
minfree xs <span class=\"synStatement\">=</span> minfrom <span class=\"synConstant\">0</span> (length xs, xs)
</pre><p>この minfree の計算量は O(N) だそうだ。</p></div>
") (dc:creator nil "kazu-yamamoto") (dc:date nil "2013-02-06T16:25:07+09:00") (dc:subject nil "Haskell"))))