;; -*- coding: utf-8 -*-
(("Tociyuki::Diary" "Tociyuki::Diary" "http://d.hatena.ne.jp/tociyuki/" (20813 17210 541909 752000) feed 0 nil nil ((title nil "Tociyuki::Diary") (link nil "http://d.hatena.ne.jp/tociyuki/") (description nil "Tociyuki::Diary") (dc:creator nil "tociyuki") (dc:date nil "2013-03-22T09:42:34+09:00") (items nil (rdf:Seq nil (rdf:li ((rdf:resource . "http://d.hatena.ne.jp/tociyuki/20130320/1363760679"))) (rdf:li ((rdf:resource . "http://d.hatena.ne.jp/tociyuki/20130318/1363582938"))) (rdf:li ((rdf:resource . "http://d.hatena.ne.jp/tociyuki/20130308/1362739025"))) (rdf:li ((rdf:resource . "http://d.hatena.ne.jp/tociyuki/20130303/1362311250"))) (rdf:li ((rdf:resource . "http://d.hatena.ne.jp/tociyuki/20130228/1362068013"))))))) ("[メモ]Flanagan 等 の CEK マシン" "Flanagan 等 The Essence of Compiling with Continuations (以下、 [Flan1993]) 図 2 に記載されている CEK マシンの動作をオリジナル CEK マシンと比べてみます。 定数 c 、 変数 x、λ式の構文ノードの扱いは両方の CEK マシンで同じです。 なお、 [Flan1993" "http://d.hatena.ne.jp/tociyuki/20130320/1363760679" (20809 22055) new 1 nil nil ((title nil "[メモ]Flanagan 等 の CEK マシン") (link nil "http://d.hatena.ne.jp/tociyuki/20130320/1363760679") (description nil " Flanagan 等 The Essence of Compiling with Continuations (以下、 [Flan1993]) 図 2 に記載されている CEK マシンの動作をオリジナル CEK マシンと比べてみます。 定数 c 、 変数 x、λ式の構文ノードの扱いは両方の CEK マシンで同じです。 なお、 [Flan1993") (content:encoded nil "
<div class=\"section\"><p>Flanagan 等 <q><a href=\"http://citeseer.ist.psu.edu/flanagan93essence.html\">The Essence of Compiling with Continuations</a></q> (以下、 &#91;Flan1993&#93;) 図 2 に記載されている CEK マシンの動作をオリジナル CEK マシンと比べてみます。</p><p>定数 c 、 変数 x、λ式の構文ノードの扱いは両方の CEK マシンで同じです。 なお、 &#91;Flan1993&#93; ではこれら 3 つの扱いをまとめて <code>γ(V, E)</code> と記述してあります。</p><pre>
    c E K → (Ret c) E K
    x (…{…x:v…}… . E) K → (Ret v) (…{…x:v…}… . E) K
    λxyz.N E K → (Ret (cl (x y z) N E)) E K
</pre><p>&#91;Flan1993&#93; は、オリジナルの実引数の評価を Scheme 処理系向けにアレンジしてあります。そこで、まず、オリジナルの流儀の CEK マシンでの <code>(let (x M) N)</code> の実引数の評価から見ていきます。 ここで、 x は束縛変数、 M と N は項です。 この関数適用は <code>(λx.N)(M)</code> ですから、 次のように遷移して実引数の評価がおこなわれた後に、 値に変数を束縛します。</p><pre>
    (λx.N)(M) E K
    → λx.N E ((Arg M E) . K)
    → (Ret (Closure x N E)) E ((Arg M E) . K)
    → M E ((Closure x N E) . K)
    → ……                                ※ M の評価を省略。
    → (Ret v) E&#39; ((Closure x N E) . K)
    → N ({x:v} . E) K
</pre><p>対応する遷移を &#91;Flan1993&#93; から抜き出します。</p><pre>
    &#60;(let (x M) N), E, K&#62;
      → &#60;M, E, &#60;lt x, N, E, K&#62;&#62;
      → &#60;&#60;lt x, N, E, K&#62;, v&#62;
      → &#60;N, ({x:v} . E), K&#62;
</pre><p>2 つ目の遷移で、 C と K だけの状態になっているのは、 <code>(Ret v) E' (k . K)</code> に相当します。 そこで、これを最初の記述に合うように書き直します。</p><pre>
    (let (x M) N) E K
    → M E ((lt x N E) . K)
    → (Ret v) E&#39; ((lt x N E) . K)
    → N ({x:v} . E) K
</pre><p>見比べてみると、 実引数の継続 (K) への登録ステップが省略されていることと、 lt が仮引数 1 個のクロージャであることがわかります。</p><p>続いて、オリジナルの CEK マシンが2個以上の実引数がある関数適用をどう扱うかを見てみます。</p><pre>
    (λxyz.M)(M1)(M2)(M3) E K
    → (λxyz.M)(M1)(M2) E ((Arg M3 E) . K)
    → (λxyz.M)(M1) E ((Arg M2 E) (Arg M3 E) . K)
    → λxyz.M E ((Arg M1 E) (Arg M2 E) (Arg M3 E) . K)
    → (Ret (Closure λxyz.M E)) E ((Arg M1 E) (Arg M2 E) (Arg M3 E) . K)
    → M1 E ((Closure λxyz.M E) (Arg M2 E) (Arg M3 E) . K)
    → ……
    → (Ret u) E&#39; ((Closure λxyz.M E) (Arg M2 E) (Arg M3 E) . K)
    → λyz.M ({x:u} . E) ((Arg M2 E) (Arg M3 E) . K)
    → (Ret (Closure λyz.M ({x:u} . E))) ({x:u} . E) ((Arg M2 E) (Arg M3 E) . K)
    → M2 E ((Closure λyz.M ({x:u} . E)) (Arg M3 E) . K)
    → ……
    → (Ret v) E&#39;&#39; ((Closure λyz.M ({x:u} . E)) (Arg M3 E) . K)
    → λz.M ({x:u y:v} . E) ((Arg M3 E) . K)
    → (Ret (Closure λz.M ({x:u y:v} . E))) ({x:u y:v} . E) ((Arg M3 E) . K)
    → M3 E ((Closure λz.M ({x:u y:v} . E)) . K)
    → ……
    → (Ret w) E&#39;&#39;&#39; ((Closure λz.M ({x:u y:v} . E)) . K)
    → M ({x:u y:v z:w} . E) K
</pre><p>実引数 M1 M2 M3 を順に評価し、 変数 x y z を束縛したレキシカル・スコープで、項 M を評価します。</p><p>対応する &#91;Flan1993&#93; の遷移は上と同じなのですけど、 途中のカリー化されたレキシカル・スコープを省略するためにカーソルを用いたトリッキーな記述になっています。</p><pre>
    ((λxyz.M) M1 M2 M3) E K
    → λxyz.M E ((ap (_ M1 M2 M3) E) . K)            ※ 下線はカーソル
    → (Ret (cl (x y z) M E)) E ((ap (_ M1 M2 M3) E) . K)
    → M1 E ((ap ((cl (x y z) M E) _ M2 M3) E) . K)
    → ……
    → (Ret u) E&#39; ((ap ((cl (x y z) M E) _ M2 M3) E) . K)
    → M2 E ((ap ((cl (x y z) M E) u _ M3) E) . K)
    → ……
    → (Ret v) E&#39;&#39; ((ap ((cl (x y z) M E) u _ M3) E) . K)
    → M3 E ((ap ((cl (x y z) M E) u v _) E) . K)
    → ……
    → (Ret w) E&#39;&#39;&#39; ((ap ((cl (x y z) M E) u v _) E) . K)
    → M ({x:u y:v z:w} . E) K
</pre><p>オリジナルの継続中のレキシカル・スコープと Arg の並びが ap になっています。 カーソルは先頭から順番に C へ抜き出すために使われ、 末尾に到達した段階で変数束縛をおこないλ式の項の評価を開始します。 この方式はプリミティブ O 摘要を同様に扱えて便利なようです。 プリミティブはクロージャを作らないので、 いきなり実引数の評価へ遷移し、 プリミティブ摘要で完了します。</p><pre>
    (O M1 M2 M3) E K
    → M1 E ((pr (_ M2 M3) E) . K)
    → ……
    → (Ret u) E&#39; ((pr (_ M2 M3) E) . K)
    → M2 E ((pr (u _ M3) E) . K)
    → ……
    → (Ret v) E&#39;&#39; ((pr (u _ M3) E) . K)
    → M3 E ((pr (u v _) E) . K)
    → ……
    → (Ret w) E&#39;&#39;&#39; ((pr (u v _) E) . K)
    → (Ret r) E K                                   ※ r = (apply-primitive O &#39;(u v w))
</pre><p>&#91;Flan1993&#93; の遷移には、 if0 特殊形式も含まれています。 <code>(if0 M0 M1 M2)</code> と記述され、 M0 がゼロのとき、 M1 を評価し、 そうでないときは M2 を評価します。</p><pre>
    (if0 M0 M1 M2) E K
    → M0 E ((if M1 M2 E) . K)
    → ……
    → (Ret v) E&#39; ((if M1 M2 E) . K)
    → M1 E K                                when v == 0
   (→ M2 E K)                               when v != 0
</pre><p>以上のように、 &#91;Flan1993&#93; 図 2 は、次のインタープリタを積極評価していることがわかります。</p><pre class=\"syntax-highlight\"><span class=\"synSpecial\">(</span><span class=\"synStatement\">define</span><span class=\"synSpecial\">(</span><span class=\"synIdentifier\">eval</span><span class=\"synIdentifier\">exp</span> env kont<span class=\"synSpecial\">)</span><span class=\"synSpecial\">(</span><span class=\"synStatement\">cond</span><span class=\"synSpecial\">((</span>self-evaluating? <span class=\"synIdentifier\">exp</span><span class=\"synSpecial\">)</span><span class=\"synSpecial\">(</span>kont <span class=\"synIdentifier\">exp</span><span class=\"synSpecial\">))</span><span class=\"synComment\">; γ(c, E)</span><span class=\"synSpecial\">((</span><span class=\"synIdentifier\">symbol?</span><span class=\"synIdentifier\">exp</span><span class=\"synSpecial\">)</span><span class=\"synSpecial\">(</span>kont <span class=\"synSpecial\">(</span>variable-lookup <span class=\"synIdentifier\">exp</span> env<span class=\"synSpecial\">))</span><span class=\"synComment\">; γ(x, E)</span><span class=\"synSpecial\">((</span>lambda? <span class=\"synIdentifier\">exp</span><span class=\"synSpecial\">)</span><span class=\"synSpecial\">(</span>kont <span class=\"synSpecial\">(</span>make-closure <span class=\"synIdentifier\">exp</span> env<span class=\"synSpecial\">))</span><span class=\"synComment\">; γ((λ (x y z) N), E)</span><span class=\"synSpecial\">((</span>if0-syntax? <span class=\"synIdentifier\">exp</span><span class=\"synSpecial\">)</span><span class=\"synComment\">; (if0 M0 M1 M2)</span><span class=\"synSpecial\">(</span><span class=\"synIdentifier\">eval</span><span class=\"synSpecial\">(</span><span class=\"synIdentifier\">cadr</span><span class=\"synIdentifier\">exp</span><span class=\"synSpecial\">)</span> env <span class=\"synSpecial\">(</span><span class=\"synStatement\">lambda</span><span class=\"synSpecial\">(</span>v0<span class=\"synSpecial\">)</span><span class=\"synSpecial\">(</span><span class=\"synStatement\">if</span><span class=\"synSpecial\">(</span><span class=\"synIdentifier\">zero?</span> v0<span class=\"synSpecial\">)</span><span class=\"synSpecial\">(</span><span class=\"synIdentifier\">eval</span><span class=\"synSpecial\">(</span><span class=\"synIdentifier\">caddr</span><span class=\"synIdentifier\">exp</span><span class=\"synSpecial\">)</span> env kont<span class=\"synSpecial\">)</span><span class=\"synSpecial\">(</span><span class=\"synIdentifier\">eval</span><span class=\"synSpecial\">(</span><span class=\"synIdentifier\">cadddr</span><span class=\"synIdentifier\">exp</span><span class=\"synSpecial\">)</span> env kont<span class=\"synSpecial\">)))))</span><span class=\"synSpecial\">((</span>application? <span class=\"synIdentifier\">exp</span><span class=\"synSpecial\">)</span><span class=\"synComment\">; (let (x M1) M)</span><span class=\"synSpecial\">(</span>evlis <span class=\"synIdentifier\">exp</span> env <span class=\"synSpecial\">(</span><span class=\"synStatement\">lambda</span><span class=\"synSpecial\">(</span>vals<span class=\"synSpecial\">)</span><span class=\"synComment\">; および (M M1 M2 M3 ..)</span><span class=\"synSpecial\">(</span><span class=\"synIdentifier\">apply</span><span class=\"synSpecial\">(</span><span class=\"synIdentifier\">car</span> vals<span class=\"synSpecial\">)</span><span class=\"synSpecial\">(</span><span class=\"synIdentifier\">cdr</span> vals<span class=\"synSpecial\">)</span> kont<span class=\"synSpecial\">))))))</span><span class=\"synComment\">; および (O M1 M2 M3 ..)</span><span class=\"synSpecial\">(</span><span class=\"synStatement\">define</span><span class=\"synSpecial\">(</span>evlis exps env kont<span class=\"synSpecial\">)</span><span class=\"synSpecial\">(</span><span class=\"synStatement\">if</span><span class=\"synSpecial\">(</span><span class=\"synIdentifier\">null?</span> exps<span class=\"synSpecial\">)</span><span class=\"synSpecial\">(</span>kont <span class=\"synSpecial\">'())</span><span class=\"synSpecial\">(</span><span class=\"synIdentifier\">eval</span><span class=\"synSpecial\">(</span><span class=\"synIdentifier\">car</span> exps<span class=\"synSpecial\">)</span> env <span class=\"synSpecial\">(</span><span class=\"synStatement\">lambda</span><span class=\"synSpecial\">(</span>v<span class=\"synSpecial\">)</span><span class=\"synSpecial\">(</span>evlis <span class=\"synSpecial\">(</span><span class=\"synIdentifier\">cdr</span> exps<span class=\"synSpecial\">)</span> env <span class=\"synSpecial\">(</span><span class=\"synStatement\">lambda</span><span class=\"synSpecial\">(</span>w<span class=\"synSpecial\">)</span><span class=\"synSpecial\">(</span>kont <span class=\"synSpecial\">(</span><span class=\"synIdentifier\">cons</span> v w<span class=\"synSpecial\">))))))))</span><span class=\"synSpecial\">(</span><span class=\"synStatement\">define</span><span class=\"synSpecial\">(</span><span class=\"synIdentifier\">apply</span> func args kont<span class=\"synSpecial\">)</span><span class=\"synSpecial\">(</span><span class=\"synStatement\">cond</span><span class=\"synSpecial\">((</span>primitive? func<span class=\"synSpecial\">)</span><span class=\"synSpecial\">(</span>apply-primitive func args kont<span class=\"synSpecial\">))</span><span class=\"synSpecial\">((</span>closure? func<span class=\"synSpecial\">)</span><span class=\"synSpecial\">(</span><span class=\"synStatement\">let</span><span class=\"synSpecial\">((</span>env <span class=\"synSpecial\">(</span>expand-environment <span class=\"synSpecial\">(</span>closure-parameters func<span class=\"synSpecial\">)</span> args <span class=\"synSpecial\">(</span>closure-environment func<span class=\"synSpecial\">))))</span><span class=\"synSpecial\">(</span><span class=\"synIdentifier\">eval</span><span class=\"synSpecial\">(</span>closure-body func<span class=\"synSpecial\">)</span> env kont<span class=\"synSpecial\">)))))</span></pre><p>Scheme 評価器として足りないのは、 変数の破壊操作とシーケンスです。 前者はプリミティブに、 後者は入れ子の <code>(let (x M) N)</code> にコンパイルできるので、 マクロをサポートしないなら、 &#91;Flan1993&#93; の CEK マシンは Scheme 積極評価器そのものと言って良いと思います。</p></div>
") (dc:creator nil "tociyuki") (dc:date nil "2013-03-20T15:24:39+09:00") (dc:subject nil "メモ"))) ("[Ruby]前置単項演算子と非結合二項演算子も扱える演算子優先順位構文解析器" "Wikipedia から直訳した「演算子優先順位構文解析器」は二項演算子で左結合か右結合のものしか扱えないので、 加えて二項演算子の非結合のものと、 前置単項演算子も扱えるように改良しました。 ついでに、 expression から直接 expression への再帰呼び出しをループに変換" "http://d.hatena.ne.jp/tociyuki/20130318/1363582938" (20806 40922) new 2 nil nil ((title nil "[Ruby]前置単項演算子と非結合二項演算子も扱える演算子優先順位構文解析器") (link nil "http://d.hatena.ne.jp/tociyuki/20130318/1363582938") (description nil " Wikipedia から直訳した「演算子優先順位構文解析器」は二項演算子で左結合か右結合のものしか扱えないので、 加えて二項演算子の非結合のものと、 前置単項演算子も扱えるように改良しました。 ついでに、 expression から直接 expression への再帰呼び出しをループに変換") (content:encoded nil "
<div class=\"section\"><p>Wikipedia から直訳した「<a href=\"http://d.hatena.ne.jp/tociyuki/20121209/1355068903\">演算子優先順位構文解析器</a>」は二項演算子で左結合か右結合のものしか扱えないので、 加えて二項演算子の非結合のものと、 前置単項演算子も扱えるように改良しました。 ついでに、 expression から直接 expression への再帰呼び出しをループに変換しました。</p><p>演算子の優先順位定義では、 同じ記号で単項演算子だったり二項演算子だったりするものがあるので、 別の演算子として扱うために、スラッシュに 1 か 2 を続けるポストフィックスをつけることで区別します。 さらに、 単項演算子の場合は、 Operator 構造体の assoc に :unary をセットしておきます。 この実装ではポストフィックスと assoc フィールドの両方を正しく記述しないと、 単項演算子として処理できません。</p><p>二項演算子で非結合なものは、 assoc を :nonassoc にします。</p><p>上向き構文解析との対応関係では、 スタックへのプッシュがシフトに、 ポップが還元になっています。 単項演算子は常にシフトします。 二項演算子はスタックのトップの演算子の優先順位と結合性によりシフトするか還元します。 二項演算子だけの版と同じく、 スタックのトップには前回シフトした演算子が入ります。 ただし、 今回は、 それが単項演算子なのか、 それとも二項演算子なのか区別をしないといけないため、 スラッシュ・ポストフィックスをつけたままでスタックへプッシュします。</p><p><ins datetime=\"2013-03-19T09:42:27+09:00\">2013年3月19日修正: 単項演算子をシフトするとき優先順位を判定するようにしました。</ins></p><pre class=\"syntax-highlight\"><span class=\"synPreProc\">#!/usr/bin/env ruby</span><span class=\"synIdentifier\">Operator</span> = <span class=\"synIdentifier\">Struct</span>.new(<span class=\"synIdentifier\">:precedence</span>, <span class=\"synIdentifier\">:assoc</span>)

<span class=\"synIdentifier\">FUNCTOR</span> = {
  <span class=\"synSpecial\">'</span><span class=\"synConstant\">or/2</span><span class=\"synSpecial\">'</span>  =&#62; <span class=\"synIdentifier\">Operator</span>.new( <span class=\"synConstant\">1</span>, <span class=\"synIdentifier\">:left</span>),
  <span class=\"synSpecial\">'</span><span class=\"synConstant\">and/2</span><span class=\"synSpecial\">'</span> =&#62; <span class=\"synIdentifier\">Operator</span>.new( <span class=\"synConstant\">2</span>, <span class=\"synIdentifier\">:left</span>),
  <span class=\"synSpecial\">'</span><span class=\"synConstant\">not/1</span><span class=\"synSpecial\">'</span> =&#62; <span class=\"synIdentifier\">Operator</span>.new( <span class=\"synConstant\">3</span>, <span class=\"synIdentifier\">:unary</span>),
  <span class=\"synSpecial\">'</span><span class=\"synConstant\">==/2</span><span class=\"synSpecial\">'</span>  =&#62; <span class=\"synIdentifier\">Operator</span>.new(<span class=\"synConstant\">10</span>, <span class=\"synIdentifier\">:nonassoc</span>),
  <span class=\"synSpecial\">'</span><span class=\"synConstant\">&#60;/2</span><span class=\"synSpecial\">'</span>   =&#62; <span class=\"synIdentifier\">Operator</span>.new(<span class=\"synConstant\">10</span>, <span class=\"synIdentifier\">:nonassoc</span>),
  <span class=\"synSpecial\">'</span><span class=\"synConstant\">+/2</span><span class=\"synSpecial\">'</span>   =&#62; <span class=\"synIdentifier\">Operator</span>.new(<span class=\"synConstant\">20</span>, <span class=\"synIdentifier\">:left</span>),
  <span class=\"synSpecial\">'</span><span class=\"synConstant\">-/2</span><span class=\"synSpecial\">'</span>   =&#62; <span class=\"synIdentifier\">Operator</span>.new(<span class=\"synConstant\">20</span>, <span class=\"synIdentifier\">:left</span>),
  <span class=\"synSpecial\">'</span><span class=\"synConstant\">*/2</span><span class=\"synSpecial\">'</span>   =&#62; <span class=\"synIdentifier\">Operator</span>.new(<span class=\"synConstant\">21</span>, <span class=\"synIdentifier\">:left</span>),
  <span class=\"synSpecial\">'</span><span class=\"synConstant\">//2</span><span class=\"synSpecial\">'</span>   =&#62; <span class=\"synIdentifier\">Operator</span>.new(<span class=\"synConstant\">21</span>, <span class=\"synIdentifier\">:left</span>),
  <span class=\"synSpecial\">'</span><span class=\"synConstant\">%/2</span><span class=\"synSpecial\">'</span>   =&#62; <span class=\"synIdentifier\">Operator</span>.new(<span class=\"synConstant\">21</span>, <span class=\"synIdentifier\">:left</span>),
  <span class=\"synSpecial\">'</span><span class=\"synConstant\">-/1</span><span class=\"synSpecial\">'</span>   =&#62; <span class=\"synIdentifier\">Operator</span>.new(<span class=\"synConstant\">22</span>, <span class=\"synIdentifier\">:unary</span>),
  <span class=\"synSpecial\">'</span><span class=\"synConstant\">**/2</span><span class=\"synSpecial\">'</span>  =&#62; <span class=\"synIdentifier\">Operator</span>.new(<span class=\"synConstant\">23</span>, <span class=\"synIdentifier\">:left</span>),
  <span class=\"synSpecial\">'</span><span class=\"synConstant\">+/1</span><span class=\"synSpecial\">'</span>   =&#62; <span class=\"synIdentifier\">Operator</span>.new(<span class=\"synConstant\">24</span>, <span class=\"synIdentifier\">:unary</span>),
  <span class=\"synSpecial\">'</span><span class=\"synConstant\">!/1</span><span class=\"synSpecial\">'</span>   =&#62; <span class=\"synIdentifier\">Operator</span>.new(<span class=\"synConstant\">24</span>, <span class=\"synIdentifier\">:unary</span>),
}

<span class=\"synPreProc\">def </span><span class=\"synIdentifier\">expression</span>(input)
  stack = []
  <span class=\"synStatement\">while</span><span class=\"synConstant\">true</span><span class=\"synStatement\">if</span><span class=\"synIdentifier\">FUNCTOR</span>.key?(input.first.to_s + <span class=\"synSpecial\">'</span><span class=\"synConstant\">/1</span><span class=\"synSpecial\">'</span>)
      unary = input.shift.to_s + <span class=\"synSpecial\">'</span><span class=\"synConstant\">/1</span><span class=\"synSpecial\">'</span><span class=\"synStatement\">if</span><span class=\"synStatement\">not</span> stack.empty?
        f = stack.last
        <span class=\"synStatement\">if</span><span class=\"synIdentifier\">FUNCTOR</span>[f].precedence &#62; <span class=\"synIdentifier\">FUNCTOR</span>[unary].precedence
          <span class=\"synStatement\">raise</span><span class=\"synSpecial\">&#34;</span><span class=\"synConstant\">Syntax error</span><span class=\"synSpecial\">&#34;</span><span class=\"synStatement\">end</span><span class=\"synStatement\">end</span>
      stack.push unary
      <span class=\"synStatement\">next</span><span class=\"synStatement\">end</span>

    expr = primary(input)

    <span class=\"synStatement\">break</span><span class=\"synStatement\">if</span><span class=\"synStatement\">not</span><span class=\"synIdentifier\">FUNCTOR</span>.key?(input.first.to_s + <span class=\"synSpecial\">'</span><span class=\"synConstant\">/2</span><span class=\"synSpecial\">'</span>)
    binary = input.shift.to_s + <span class=\"synSpecial\">'</span><span class=\"synConstant\">/2</span><span class=\"synSpecial\">'</span><span class=\"synStatement\">while</span><span class=\"synStatement\">not</span> stack.empty?
      f = stack.last
      operator = f.chop.chop!
      <span class=\"synStatement\">break</span><span class=\"synStatement\">if</span><span class=\"synIdentifier\">FUNCTOR</span>[f].precedence &#60; <span class=\"synIdentifier\">FUNCTOR</span>[binary].precedence
      <span class=\"synStatement\">if</span><span class=\"synIdentifier\">FUNCTOR</span>[f].assoc == <span class=\"synIdentifier\">:unary</span>
        stack.pop
        expr = [operator, expr]
      <span class=\"synStatement\">else</span><span class=\"synStatement\">if</span><span class=\"synIdentifier\">FUNCTOR</span>[f].assoc == <span class=\"synIdentifier\">:nonassoc</span><span class=\"synStatement\">and</span><span class=\"synIdentifier\">FUNCTOR</span>[binary].assoc == <span class=\"synIdentifier\">:nonassoc</span><span class=\"synStatement\">raise</span><span class=\"synSpecial\">&#34;</span><span class=\"synConstant\">Syntax error</span><span class=\"synSpecial\">&#34;</span><span class=\"synStatement\">end</span><span class=\"synStatement\">break</span><span class=\"synStatement\">if</span><span class=\"synIdentifier\">FUNCTOR</span>[f].precedence == <span class=\"synIdentifier\">FUNCTOR</span>[binary].precedence \\
              &#38;&#38; <span class=\"synIdentifier\">FUNCTOR</span>[f].assoc != <span class=\"synIdentifier\">:left</span>
        lhs ,= stack.pop(<span class=\"synConstant\">2</span>)
        expr = [lhs, operator, expr]
      <span class=\"synStatement\">end</span><span class=\"synStatement\">end</span>
    stack.push expr, binary
  <span class=\"synStatement\">end</span><span class=\"synStatement\">while</span><span class=\"synStatement\">not</span> stack.empty?
    f = stack.pop
    operator = f.chop.chop!
    <span class=\"synStatement\">if</span><span class=\"synIdentifier\">FUNCTOR</span>[f].assoc == <span class=\"synIdentifier\">:unary</span>
      expr = [operator, expr]
    <span class=\"synStatement\">else</span>
      lhs = stack.pop
      expr = [lhs, operator, expr]
    <span class=\"synStatement\">end</span><span class=\"synStatement\">end</span>
  expr
<span class=\"synPreProc\">end</span><span class=\"synPreProc\">def </span><span class=\"synIdentifier\">primary</span>(input)
  <span class=\"synStatement\">case</span> input.first
  <span class=\"synStatement\">when</span><span class=\"synIdentifier\">Numeric</span><span class=\"synStatement\">return</span> input.shift
  <span class=\"synStatement\">when</span><span class=\"synSpecial\">'</span><span class=\"synConstant\">(</span><span class=\"synSpecial\">'</span>
    input.shift
    v = expression(input)
    input.first == <span class=\"synSpecial\">'</span><span class=\"synConstant\">)</span><span class=\"synSpecial\">'</span><span class=\"synStatement\">or</span><span class=\"synStatement\">raise</span><span class=\"synSpecial\">&#34;</span><span class=\"synConstant\">Syntax error</span><span class=\"synSpecial\">&#34;</span>
    input.shift
    <span class=\"synStatement\">return</span> v
  <span class=\"synStatement\">else</span><span class=\"synStatement\">raise</span><span class=\"synSpecial\">&#34;</span><span class=\"synConstant\">Syntax error</span><span class=\"synSpecial\">&#34;</span><span class=\"synStatement\">end</span><span class=\"synPreProc\">end</span>

p expression([<span class=\"synSpecial\">'</span><span class=\"synConstant\">not</span><span class=\"synSpecial\">'</span>, <span class=\"synSpecial\">'</span><span class=\"synConstant\">-</span><span class=\"synSpecial\">'</span>, <span class=\"synConstant\">2</span>, <span class=\"synSpecial\">'</span><span class=\"synConstant\">&#60;</span><span class=\"synSpecial\">'</span>, <span class=\"synConstant\">3</span>, <span class=\"synSpecial\">'</span><span class=\"synConstant\">+</span><span class=\"synSpecial\">'</span>, <span class=\"synConstant\">4</span>, <span class=\"synSpecial\">'</span><span class=\"synConstant\">*</span><span class=\"synSpecial\">'</span>, <span class=\"synConstant\">5</span> , <span class=\"synSpecial\">'</span><span class=\"synConstant\">+</span><span class=\"synSpecial\">'</span>, <span class=\"synConstant\">6</span>, <span class=\"synSpecial\">'</span><span class=\"synConstant\">and</span><span class=\"synSpecial\">'</span>, <span class=\"synConstant\">10</span>, <span class=\"synSpecial\">'</span><span class=\"synConstant\">==</span><span class=\"synSpecial\">'</span>, <span class=\"synConstant\">10</span>])
<span class=\"synComment\">#=&#62; [[&#34;not&#34;, [[&#34;-&#34;, 2], &#34;&#60;&#34;, [[3, &#34;+&#34;, [4, &#34;*&#34;, 5]], &#34;+&#34;, 6]]], &#34;and&#34;, [10, &#34;==&#34;, 10]]</span>
p expression([<span class=\"synSpecial\">'</span><span class=\"synConstant\">!</span><span class=\"synSpecial\">'</span>, <span class=\"synSpecial\">'</span><span class=\"synConstant\">-</span><span class=\"synSpecial\">'</span>, <span class=\"synConstant\">2</span>, <span class=\"synSpecial\">'</span><span class=\"synConstant\">&#60;</span><span class=\"synSpecial\">'</span>, <span class=\"synConstant\">3</span>, <span class=\"synSpecial\">'</span><span class=\"synConstant\">+</span><span class=\"synSpecial\">'</span>, <span class=\"synConstant\">4</span>, <span class=\"synSpecial\">'</span><span class=\"synConstant\">*</span><span class=\"synSpecial\">'</span>, <span class=\"synConstant\">5</span> , <span class=\"synSpecial\">'</span><span class=\"synConstant\">+</span><span class=\"synSpecial\">'</span>, <span class=\"synConstant\">6</span>, <span class=\"synSpecial\">'</span><span class=\"synConstant\">and</span><span class=\"synSpecial\">'</span>, <span class=\"synConstant\">10</span>, <span class=\"synSpecial\">'</span><span class=\"synConstant\">==</span><span class=\"synSpecial\">'</span>, <span class=\"synConstant\">10</span>])
<span class=\"synComment\">#=&#62; [[[&#34;!&#34;, [&#34;-&#34;, 2]], &#34;&#60;&#34;, [[3, &#34;+&#34;, [4, &#34;*&#34;, 5]], &#34;+&#34;, 6]], &#34;and&#34;, [10, &#34;==&#34;, 10]]</span></pre></div>
") (dc:creator nil "tociyuki") (dc:date nil "2013-03-18T14:02:18+09:00") (dc:subject nil "Ruby"))) ("[Ruby]Landin の J オペレータ" "また懐古趣味です。 構造化プログラミングのスローガンの下、ラベルと goto 文が有害視されだしてから 40 年以上経った今でも、 頑固にある種のラベルと goto を積極的に使ったプログラミング・スタイルを堅持しているのが Scheme です。 その種のラベルと goto こそが Land" "http://d.hatena.ne.jp/tociyuki/20130308/1362739025" (20793 48977) new 3 nil nil ((title nil "[Ruby]Landin の J オペレータ") (link nil "http://d.hatena.ne.jp/tociyuki/20130308/1362739025") (description nil " また懐古趣味です。 構造化プログラミングのスローガンの下、ラベルと goto 文が有害視されだしてから 40 年以上経った今でも、 頑固にある種のラベルと goto を積極的に使ったプログラミング・スタイルを堅持しているのが Scheme です。 その種のラベルと goto こそが Land") (content:encoded nil "
<div class=\"section\"><p>また懐古趣味です。 </p><p>構造化プログラミングのスローガンの下、ラベルと goto 文が有害視されだしてから 40 年以上経った今でも、 頑固にある種のラベルと goto を積極的に使ったプログラミング・スタイルを堅持しているのが Scheme です。 その種のラベルと goto こそが Landin の J オペレータです。 P. J. Landin が J オペレータを導入したのは 1965 年のことでしたが、 あまりにさりげなかったためか、 それとも、 まさしく goto 有害論の時代の最中だったためか、 その重要性に気づいた人は少なかったようです。 J オペレータ、 つまりはある種のラベルと goto が見直されたのは、 構造化プログラミング運動がそろそろ一段落つき始めた 1970 年前半に入ってからのようです。 そして、 たった 1 文字の J では受けが良くないと、 Sussman 等が 12 文字の長くて恰好良さそうな continuation の語を当てはめることを思いついて Scheme 言語を作ってラムダ論文で布教活動に精を出すに及び、 その種のラベルと goto に復権の時が訪れます。</p><p>その種のラベルと goto とは何か。 goto 自体はどうでも良い扱いで、 大切なのは、ラベルが表しているλ関数を意識することです。</p><blockquote><p>⇒ P. J. Landin, <q>A Correspondence Between ALGOL 60 and Church's Lambda-Notation: Part I</q>, 1965, Communications of the ACM, Vol. 8, Number 2, page 92</p><p>We call an expression of the form</p><pre>
          J(λL・S)
</pre><p>a <q>program-point.</q> Roughly speaking, ALGOL 60's labels are a special case of program-points. They are parameterless, and the λ-body is typically a functional product whose terms correspond to the statements following the label.</p></blockquote><p>これは私見ですけど、 Landin が J オペレータを導入したとき、 見過ごされてしまったのは、 そんなことはあまりに当たり前すぎたからではないかという気がしています。 Landin 自身からして、 特別なことをしている意識はたぶんなかったのじゃないかと、 論文を読んでみると、 そこはかとなく感じとれます。 その当時でも、 LISP 1.5 には PROG 形式が既に実装されており、ラベルと GOTO を使って関数のシーケンスを順次実行できるようになっていました。 というよりも、 1980 年当時の LISP 処理系でも再帰呼び出しを避けて、 破壊操作と GOTO によるループでリストを処理するプログラミング・スタイルの方が主流でした。 現実を目の当たりにしていたので、 LISP を関数型プログラミング言語に入っているのが肌感覚に合わず、 私は LISP をリスト操作向けの手続き型言語だと認識しているぐらいです。 1980 年代でもそうだったのですから、 1960 年代ならなおさらでしょう。 そのような時代背景から SECD マシンに J オペレータがあるのは不思議でもなんでもないと思われていたのかもしれません。</p><p>やがて年数を経て Scheme が産み出されている同時期に、 J オペレータの重要性に気がついていた人たちが複数いたようです。 それらを D. Knuth が参照しつつ、 1974 年に論文とエッセーの両面を持つ味わい深い短篇「goto 文を用いた構造的プログラミング」を公表しています。 幸いこの短篇は、 後に「文芸的プログラミング」に収録されています。 その中で goto 文を使った方が書きやすい事例として、 再帰呼び出しをループ化したコードを立て続けに紹介してから、 C. T. Zahn の状況指定子付きループ文を使って例題を書き直したところに、 次の一文が挿入されています。 そこでの例題は， 単純な 2 分木を作るコードの断片になっています．</p><blockquote><p>⇒ D. Knuth、「文芸的プログラミング」、1994、アスキー出版、ISBN4-7561-0190-9</p><p>実際， この状況の利用は， 意味論上は制限した goto 文と同じで， Peter Landin が 1965 年に論じていたものの， われわれの多くは耳を貸さなかったのである． Landin が用いた機構を Clint と Hoare が次のように再生した． 名札はそれぞれブロックの先頭で， 通常の手続きと同様に宣言する． 名札には， 手続きが〈手続きの本体〉をもつのと同様に〈名札の本体〉がある． 名札 <i>L</i> の宣言をしたブロックの中では， goto <i>L</i> は「名札 <i>L</i> の本体を実行して，ブロックから抜け出す」ことを意味する． これが Zahn の状況を用いた機構と同じであることはすぐにわかる． 〈名札の本体〉が then ... fi の中の〈文の並び〉の後処理に相当し， 〈状況〉が Landin の go to と対応する． したがって， Clint と Hoare の記法で例題 5b を書けば， 次のようになる．</p><pre>
    while true do
      begin label left leaf hit; L&#91;i] := j;
        label right leaf hit; R&#91;i] := j;
        if A&#91;i] &#60; x
        then if L&#91;i] ≠ 0 then i := L&#91;i];
          else goto left leaf hit fi;
        else if R&#91;i] ≠ 0 then i := R&#91;i];
          else goto right leaf hit fi;
        fi;
      end;
    A&#91;j] := x; L&#91;j] := 0; R&#91;j] := 0; j := j + 1;
</pre><p>〈名札の本体〉が論理的に先行するものと後行するものとの間にはさまっていることから， 私は Zahn の形よりこちらのほうがずっと読みやすいように思う．</p><p>Landin はまた， 名札にも手続きと同様にパラメタをもつことを許した． これは Zahn の提案に対する貴重な拡張であり， 以下では値渡しパラメタをもつ状況を， いくつかの実例で使用したい．</p></blockquote><p>引用したコードの説明をしておいた方が良いでしょう。 これの元は D. Knuth <q>The Art Of Computer Programing Vol. 3 </q> 6.2.2 アルゴリズム T です<span class=\"footnote\"><a href=\"/tociyuki/#f1\" name=\"fn1\" title=\"引用元では 6.2.3 C と記載されていますが、 そちらはバランス 2 分木の挿入で別ものです。\">*1</a></span>。 2 分木にエントリを追加するコードで、 今は再帰呼び出しで記述する方が主流です。 それをループにしたのがこのアルゴリズムです。 構造体とポインタを使わず、 3つの配列 A、 R、 L を使い、 添字ゼロを nil 扱いにしています。 A が値、R が右枝ノードの添字、 L が左枝ノードの添字です。</p><p>再帰呼び出し版を Ruby 1.9 で記述するとこうなります。</p><pre class=\"syntax-highlight\"><span class=\"synPreProc\">require</span><span class=\"synSpecial\">'</span><span class=\"synConstant\">pp</span><span class=\"synSpecial\">'</span><span class=\"synIdentifier\">Node</span> = <span class=\"synIdentifier\">Struct</span>.new(<span class=\"synIdentifier\">:value</span>, <span class=\"synIdentifier\">:left</span>, <span class=\"synIdentifier\">:right</span>)

<span class=\"synPreProc\">def </span><span class=\"synIdentifier\">binary_tree_insert</span>(node, x)
  <span class=\"synStatement\">if</span> node.value &#60; x
    <span class=\"synStatement\">if</span><span class=\"synStatement\">not</span> node.left.nil?
      binary_tree_insert(node.left, x)
    <span class=\"synStatement\">else</span>
      node.left = <span class=\"synIdentifier\">Node</span>.new(x)
    <span class=\"synStatement\">end</span><span class=\"synStatement\">else</span><span class=\"synStatement\">if</span><span class=\"synStatement\">not</span> node.right.nil?
      binary_tree_insert(node.right, x)
    <span class=\"synStatement\">else</span>
      node.right = <span class=\"synIdentifier\">Node</span>.new(x)
    <span class=\"synStatement\">end</span><span class=\"synStatement\">end</span><span class=\"synPreProc\">end</span>

a = (<span class=\"synConstant\">1</span> .. <span class=\"synConstant\">9</span>).to_a.shuffle
root = <span class=\"synIdentifier\">Node</span>.new(a.shift)
a.each {|<span class=\"synIdentifier\">x</span>| binary_tree_insert(root, x) }
pp root
</pre><p>状況が一つだけの場合はループから break や return で抜け出すやりかたに相当します。 状況が一つのときの例題 5c を Ruby に書き直してみました。 Ruby の制御文では Landin の J オペレータのパラメータなしは、 break、 continue に、 パラメータありは return、 throw、 raise になります。</p><pre class=\"syntax-highlight\"><span class=\"synPreProc\">def </span><span class=\"synIdentifier\">binary_tree_insert</span>(node, x)
  <span class=\"synStatement\">while</span><span class=\"synConstant\">true</span><span class=\"synStatement\">if</span> node.value &#60; x
      <span class=\"synStatement\">if</span><span class=\"synStatement\">not</span> node.left.nil?
        node = node.left
      <span class=\"synStatement\">else</span>
        leaf = node.left = <span class=\"synIdentifier\">Node</span>.new
        <span class=\"synStatement\">break</span><span class=\"synStatement\">end</span><span class=\"synStatement\">else</span><span class=\"synStatement\">if</span><span class=\"synStatement\">not</span> node.right.nil?
        node = node.right
      <span class=\"synStatement\">else</span>
        leaf = node.right = <span class=\"synIdentifier\">Node</span>.new
        <span class=\"synStatement\">break</span><span class=\"synStatement\">end</span><span class=\"synStatement\">end</span><span class=\"synStatement\">end</span>
  leaf.value = x
<span class=\"synPreProc\">end</span></pre><p>ループを使うなら、 上の通りなのですが、 Landin のパラメタ付きの J オペレータを使うことで、 再帰呼び出しで書いてあるのにループ動作をするように記述できます。 Scheme で書くと何の変哲もない再帰呼び出し記述になってしまって goto なのがわかりにくいため、 ここでは Ruby 1.9 で書いてみることにします。</p><pre class=\"syntax-highlight\"><span class=\"synPreProc\">class </span><span class=\"synType\">Proc</span><span class=\"synPreProc\">def </span><span class=\"synIdentifier\">call_with_continuation</span>(*a)
    x = call(*a)
    x = x.call <span class=\"synStatement\">while</span><span class=\"synIdentifier\">Proc</span> === x
    x
  <span class=\"synPreProc\">end</span><span class=\"synPreProc\">end</span><span class=\"synPreProc\">def </span><span class=\"synIdentifier\">binary_tree_insert</span>(root, x)
  hit_left  = <span class=\"synStatement\">lambda</span> {|<span class=\"synIdentifier\">parent, k</span>| k.call(parent.left  = <span class=\"synIdentifier\">Node</span>.new) }
  hit_right = <span class=\"synStatement\">lambda</span> {|<span class=\"synIdentifier\">parent, k</span>| k.call(parent.right = <span class=\"synIdentifier\">Node</span>.new) }
  compare = <span class=\"synStatement\">lambda</span><span class=\"synStatement\">do</span> |<span class=\"synIdentifier\">node, k</span>|
    <span class=\"synStatement\">if</span> node.value &#62; x
      <span class=\"synStatement\">if</span> node.left.nil?
        -&#62;{ hit_left[node, k] }
      <span class=\"synStatement\">else</span>
        -&#62;{ compare[node.left, k] }
      <span class=\"synStatement\">end</span><span class=\"synStatement\">else</span><span class=\"synStatement\">if</span> node.right.nil?
        -&#62;{ hit_right[node, k] }
      <span class=\"synStatement\">else</span>
        -&#62;{ compare[node.right, k] }
      <span class=\"synStatement\">end</span><span class=\"synStatement\">end</span><span class=\"synStatement\">end</span>
  leaf = compare.call_with_continuation(root, -&#62;(x){x})
  leaf.value = x
<span class=\"synPreProc\">end</span></pre><p>引用している 5b の書き直し版を、 Scheme の流儀で Ruby 1.9 に直訳したものです。 ここで、 k は継続渡しスタイル (CPS) で渡される継続です。 Proc クラスにメソッドを追加して、 Ruby インタプリタ・レベルで CEK マシンとほぼ同じ動作をさせています。 なお、 Ruby 1.9 では、 ラムダ関数の表記に従来の Kernel#lambda 関数に加え、 矢印の表記が加わりました。 上では両方を意図的に使い分けています。 lambda は Landin の label を表し、 矢印は goto を表します。</p><p>Ruby では CPS に限らず、 継続を使った書き方は技巧的に見えますが、 Scheme では入れ子の手続き define やラベル付き let を使うことで、 Landin の J オペレータをそれと意識することなく常用することができます。 それだけでなく、 R1RS 以来、 末尾の関数適用はジャンプ扱いにしなければならないため、 内部動作も goto そのものになっています。 D. Knuth が愛情を注いだ状況 goto は、 Scheme に自然な形で受け継がれ使われ続けています。</p></div><div class=\"footnote\"><p class=\"footnote\"><a href=\"/tociyuki/#fn1\" name=\"f1\">*1</a>：引用元では 6.2.3 C と記載されていますが、 そちらはバランス 2 分木の挿入で別ものです。</p></div>
") (dc:creator nil "tociyuki") (dc:date nil "2013-03-08T19:37:05+09:00") (dc:subject nil "Ruby"))) ("[Ruby]文法記号列の FIRST 集合と FOLLOW 集合" "ある構文規則が、 どの文法に属するのか調べるときに、 文法記号列の FIRST 集合と FOLLOW 集合の助けが必要になってきます。 文法記号列を A とするとき、 FIRST(A) は A から導出可能な記号列の先頭に現れる記号を集めたものです。 また、非終端記号 A に対して A が導出" "http://d.hatena.ne.jp/tociyuki/20130303/1362311250" (20787 14418) new 4 nil nil ((title nil "[Ruby]文法記号列の FIRST 集合と FOLLOW 集合") (link nil "http://d.hatena.ne.jp/tociyuki/20130303/1362311250") (description nil " ある構文規則が、 どの文法に属するのか調べるときに、 文法記号列の FIRST 集合と FOLLOW 集合の助けが必要になってきます。 文法記号列を A とするとき、 FIRST(A) は A から導出可能な記号列の先頭に現れる記号を集めたものです。 また、非終端記号 A に対して A が導出") (content:encoded nil "
<div class=\"section\"><p>ある構文規則が、 どの文法に属するのか調べるときに、 文法記号列の FIRST 集合と FOLLOW 集合の助けが必要になってきます。 文法記号列を A とするとき、 FIRST(A) は A から導出可能な記号列の先頭に現れる記号を集めたものです。 また、非終端記号 A に対して A が導出する記号列の直後に現れる記号を集めたものを FOLLOW(A) 集合と呼びます。</p><p>構文規則が簡単なときは、 目で追うだけで両方とも求まるものですが、 複雑になってくると、 FIRST はともかく、 FOLLOW を求めるのは大変になってきます。 自動化したいということで、 試しにスクリプトを書いてみました。このスクリプトは Oberon-0 言語の全構文規則から、 それぞれの非終端記号ごとに FIRST と FOLLOW を求めてリストアップします。</p><p>⇒ <a href=\"https://gist.github.com/tociyuki/5075535\" target=\"_self\">https://gist.github.com/tociyuki/5075535</a></p><p>Oberon-0 言語は、これのコンパイラを作成する授業で使うために定義された小さな手続き型言語です。 Wirth 教授のサイトから、コンパイラを作る教科書の PDF をダウンロードして読むことができます。</p><p>⇒ <a href=\"http://www.inf.ethz.ch/personal/wirth/index.html\" target=\"_self\">http://www.inf.ethz.ch/personal/wirth/index.html</a></p><p><ins datetime=\"2013-03-04T23:15:06+09:00\">2013年3月4日追記</ins>: この文献には、 Oberon-0 の EBNF が 30 ページと 112 ページに 2 回掲載されており、 前者と後者は一ヶ所違いがあります。 ProcedureCall に selector が使えるかどうかが異なっています。 さらに、本文 34 ページ記載の Follow(selector) は 112 ページの selector なしの生成規則に一致している一方で、 構文解析器のコードでは 80 ページと 119 ページの両方の手続き呼び出し記載箇所では selector ありになっています。 意味定義がない言語なので、 どちらが正しいのか不明ですが、 とりあえず Ruby スクリプトで使う規則は 112 ページの selector なしにしておきます。</p><blockquote><p>上が 30 ページ、 下が 112 ページ。</p><pre class=\"syntax-highlight\"><span class=\"synSpecial\">-ProcedureCall = ident selector [ActualParameters].</span><span class=\"synIdentifier\">+ProcedureCall = ident [ActualParameters].</span></pre></blockquote><p>その構文は EBNF で 28 の規則で記述されています。 BNF へ展開すると、 規則数が倍近く増えるものの、 それでも私が展開したものは 52 規則です。 こんなに小さくても、 配列・構造体・入れ子手続き・手続きへの値渡しと参照渡しの仮引数の機能を持っています。 ポインタは使えません。</p><p>なお、 EBNF は LL(k) 文法で記述されており、 私が展開した BNF 版では LL(1) 文法に書き換えてあります。 LL(k) な場所は一ヶ所だけで、 代入文と手続き呼び出し文の区別が、 代入記号か左括弧か文末のどれかに到達したときに始めて決定します。 Wirth 教授作の Oberon の再帰下降型で記述された構文解析器は、 LL(1) として解釈を進めていき、 区別がついた段階で処理を振り分けています。 私の LL(1) 文法版では、 実装にならって構文上はどちらでもある状態として進めるように非終端記号を一つにまとめました。</p><p>FIRST 集合と FOLLOW 集合を求める手順は、 それぞれの非終端記号ごとに割り当ててある集合から集合へと記号を浸透させていく方法をとりました。 全非終端記号の集合に浸透しきって集合に変化がなくなるまで、浸透を繰り返し続けます。</p><p>このスクリプトで使っているアルゴリズムは、Aho 等「<a href=\"http://d.hatena.ne.jp/asin/478191229X\">コンパイラ―原理・技法・ツール (Information & Computing)</a>」 238、239 ページ記載の規則から、無理やりひねくりだしたものです。苦し紛れというか、やっつけ感が漂っているのは、アルゴリズム含めて私のオリジナルだからであって、 大先生達の落ち度ではありません。</p><pre class=\"syntax-highlight\"><span class=\"synPreProc\">def </span><span class=\"synIdentifier\">compose_first_set</span>(grammar)
    first = <span class=\"synIdentifier\">SetBuilder</span>.new
    <span class=\"synStatement\">begin</span>
      first.changed = <span class=\"synConstant\">false</span>
      grammar.each <span class=\"synStatement\">do</span> |<span class=\"synIdentifier\">x</span>|
        first.unterminal(x.lft)
        (x.rgt.empty? <span class=\"synStatement\">or</span> x.rgt.all? {|<span class=\"synIdentifier\">y</span>|
          <span class=\"synStatement\">if</span> first.terminal?(y)
            first.terminal(x.lft, y)
          <span class=\"synStatement\">else</span>
            first.unterminal(y).each {|<span class=\"synIdentifier\">a</span>|
              a.equal?(<span class=\"synIdentifier\">EMPTY</span>) <span class=\"synStatement\">or</span> first.terminal(x.lft, a)
            }
            first.unterminal(y).include?(<span class=\"synIdentifier\">EMPTY</span>)
          <span class=\"synStatement\">end</span>
        }) <span class=\"synStatement\">and</span> first.terminal(x.lft, <span class=\"synIdentifier\">EMPTY</span>)
      <span class=\"synStatement\">end</span><span class=\"synStatement\">end</span><span class=\"synStatement\">while</span> first.changed
    first.set
  <span class=\"synPreProc\">end</span><span class=\"synPreProc\">def </span><span class=\"synIdentifier\">compose_follow_set</span>(grammar, first_set)
    follow = <span class=\"synIdentifier\">SetBuilder</span>.new
    follow.terminal(grammar.first.lft, <span class=\"synIdentifier\">ENDMARK</span>)
    <span class=\"synStatement\">begin</span>
      follow.changed = <span class=\"synConstant\">false</span>
      grammar.each <span class=\"synStatement\">do</span> |<span class=\"synIdentifier\">a</span>|
        follow.unterminal(a.lft)
        a.rgt.each_cons(<span class=\"synConstant\">2</span>) <span class=\"synStatement\">do</span> |<span class=\"synIdentifier\">b, beta</span>|
          <span class=\"synStatement\">next</span><span class=\"synStatement\">if</span> follow.terminal?(b)
          <span class=\"synStatement\">if</span> follow.terminal?(beta)
            follow.terminal(b, beta)
          <span class=\"synStatement\">else</span>
            first_set[beta].each{|<span class=\"synIdentifier\">x</span>| x.equal?(<span class=\"synIdentifier\">EMPTY</span>) <span class=\"synStatement\">or</span> follow.terminal(b, x) }
            <span class=\"synStatement\">if</span> first_set[beta].include?(<span class=\"synIdentifier\">EMPTY</span>)
              follow.unterminal(beta).each{|<span class=\"synIdentifier\">x</span>| follow.terminal(b, x) }
            <span class=\"synStatement\">end</span><span class=\"synStatement\">end</span><span class=\"synStatement\">end</span>
        a.rgt.reverse_each <span class=\"synStatement\">do</span> |<span class=\"synIdentifier\">b</span>|
          <span class=\"synStatement\">break</span><span class=\"synStatement\">if</span> follow.terminal?(b)
          follow.unterminal(a.lft).each{|<span class=\"synIdentifier\">x</span>| follow.terminal(b, x) }
          <span class=\"synStatement\">break</span><span class=\"synStatement\">if</span><span class=\"synStatement\">not</span> first_set[b].include?(<span class=\"synIdentifier\">EMPTY</span>)
        <span class=\"synStatement\">end</span><span class=\"synStatement\">end</span><span class=\"synStatement\">end</span><span class=\"synStatement\">while</span> follow.changed
    follow.set
  <span class=\"synPreProc\">end</span></pre></div>
") (dc:creator nil "tociyuki") (dc:date nil "2013-03-03T20:47:30+09:00") (dc:subject nil "Ruby"))) ("[メモ]Prolog インタープリタにあるリネーム・マクロの祖先" "懐古趣味の続きです。 Kohlbecker が 1986 年に提案した健全なマクロ (Hygienic macro) の実装の仕方を見たとき、 「あれ、これ、どっかで見たことあるなぁ」と感じたものです。 当時、 何を頭に思い浮かべていたかというと、 Prolog の単一化処理の際におこなう変数のリネ" "http://d.hatena.ne.jp/tociyuki/20130228/1362068013" (20783 33325) new 5 nil nil ((title nil "[メモ]Prolog インタープリタにあるリネーム・マクロの祖先 ") (link nil "http://d.hatena.ne.jp/tociyuki/20130228/1362068013") (description nil " 懐古趣味の続きです。 Kohlbecker が 1986 年に提案した健全なマクロ (Hygienic macro) の実装の仕方を見たとき、 「あれ、これ、どっかで見たことあるなぁ」と感じたものです。 当時、 何を頭に思い浮かべていたかというと、 Prolog の単一化処理の際におこなう変数のリネ") (content:encoded nil "
<div class=\"section\"><p>懐古趣味の続きです。 Kohlbecker が 1986 年に提案した健全なマクロ (Hygienic macro) の実装の仕方を見たとき、 「あれ、これ、どっかで見たことあるなぁ」と感じたものです。 当時、 何を頭に思い浮かべていたかというと、 Prolog の単一化処理の際におこなう変数のリネームのやりかたでした。</p><p>Prolog では一種の参照渡しをおこないつつ同じ節を再帰的に単一化するため、 独特のやっかいな問題が生じます。 単純に実装するには唯一の環境フレームを使う代わりに節をマクロ扱いして、 単一化する前の実行時に節内の変数に識別番号を追加するなりしてリネームし、新しい節へと丸ごとコピー生成する方法があります。 このやりかたを採用していた実装は 1980 年代にいくつかあり、 Prolog-KABA もその一つだったはずです。 Scheme での Prolog 風の処理系実装例としては、 サスマン等「計算機プログラムの構造と解釈 第二版」(SICP本)の 284 ページと 290 ページにこの方法が載っています。 論理型プログラムのためのインタープリタの一部で、 論理変数シンボルをリストで表現し、 リストにシリアル番号を追加して識別子にしています。</p><p>一方で、 節をそのまま使い変数シンボルのリネームと同じ効果を得る方法もいくつかあります。 Prolog インタープリタの実装で割と良く目にしたのは、 複数の環境フレームを利用しつつ項と(その項の中に含まれる変数が属する)環境を組にして、 項と環境の組へ変数を束縛するやりかたでした。 同じシンボルの変数でも属している環境が異なれば、 別の変数扱いになるのでそれでいいのです。 複数の環境を使ってリネームをおこなうやりかたにはコンパイラ向きの方法もあり、 現代の Prolog コンパイラはそれらを採用しています。</p><p>この値と環境を組む方式は DEC-10 Prolog がそうだったはずと、 ソースコードがどこか Web 上に転がってないものか、 そのものでなくても、自分が覚えている古いスタイルの Prolog インタープリタがないものかと探していたところ、 意表をつくものが見つかりました。 GNU Smalltalk の examples にある、 青木淳先生等による力作、 Prolog インタープリタ処理系です。 コードを追ってみたら、 そうそう、 こんな感じでデータ値と環境を組にして、変数シンボルと関連付けがしてあったものです。 ちなみに、 同じ examples には同先生等による LISP 1.5 インタープリタも入っていて、 LISP 1.5 Manual 直訳という感じです。 この 2 つもどこかで見たことがあったので、 SRA でググって Mei システムの中に見つけました。 Mei システムの方が古い感じです。</p><p>GNU Smalltalk 本家のリポジトリよりも github のミラーの方が、 シンタックス・ハイライトされて見やすいので、 そちらにリンクを張っておきます。</p><p>⇒ <a href=\"https://github.com/gnu-smalltalk/smalltalk/blob/master/examples/Prolog.st\">smalltalk/examples/Prolog.st GitHub</a></p><p>1760 行目からの binding and unbinding カテゴリのメソッド記述が変数束縛に使われており、 Prolog ですから、 当然単一化処理だけがこのあたりを利用して変数を項や変数参照へ束縛します。 単一化処理はコードの末尾にあります。 単一化するときも、 項と環境の組を使います。 この Prolog のインタープリタのコア部分は、 Smalltalk 構文を使った事実上 LISP 1.5 で記述されており、 複合データはバックトラックのダンプフレームを除いてすべてリストのペアで構成されています。</p><p>変数束縛の逆操作、 つまり SICP本の 279 ページにある参照を辿って値を取り出して項を再構築する instansiate に相当する、 Prolog.st のメソッドは 2351 行にある <code>represent&#58;env&#58;</code> です。 この手のProlog 実装の変数参照を例えるならファイル・システムのシンボリック・リンクのようなものです。 変数参照から変数参照へと数珠つなぎに値になるまで辿っていく動作は、環境と変数リネームの方式が違っていても、 同じです。</p><p>2013年3月1日追記: 1983 年に DEC-10 Prolog の作者 Warren が新しい Prolog 仮想機械 (WAM) を定義して以来、 1970 年代半ばの DEC-10 Prolog の仮想機械インタープリタのコードは過去の遺物扱いになったようでもはや Web 上から辿れる場所には存在しないようです。 ところで、上記の Prolog.st が使っている項と環境の組へ変数を束縛する方法は Boyer と Moore が 1971 年に提案した方式で、 <a href=\"http://www.cs.utexas.edu/~moore/best-ideas/structure-sharing/index.html\">Structure-Sharing</a> と呼びます。 一方、 WAM は Mellish の Structure-Copying (1982) を採用しており、 こちらはいろんな実装があってソースコードも豊富です。</p><p>いろんな Prolog 処理系実装のコレクションはカーネギー・メロン大学のリポジトリが充実しています。</p><p>⇒ <a href=\"http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/prolog/0.html\" target=\"_self\">http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/prolog/0.html</a></p></div>
") (dc:creator nil "tociyuki") (dc:date nil "2013-03-01T01:13:33+09:00") (dc:subject nil "メモ"))))